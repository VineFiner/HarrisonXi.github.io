<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>苹果梨的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.harrisonxi.com/"/>
  <updated>2019-02-28T09:24:12.172Z</updated>
  <id>http://blog.harrisonxi.com/</id>
  
  <author>
    <name>苹果梨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>字符串比较中NSNumericSearch选项的工作原理</title>
    <link href="http://blog.harrisonxi.com/2019/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83%E4%B8%ADNSNumericSearch%E9%80%89%E9%A1%B9%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.html"/>
    <id>http://blog.harrisonxi.com/2019/02/字符串比较中NSNumericSearch选项的工作原理.html</id>
    <published>2019-02-27T16:00:00.000Z</published>
    <updated>2019-02-28T09:24:12.172Z</updated>
    
    <content type="html"><![CDATA[<p>相信研究过怎么在 ObjC 中进行版本字符串比对的朋友，大多都看过这一篇 StackOverflow 的问答：</p><p><a href="https://stackoverflow.com/a/1990854/2562905" target="_blank" rel="noopener">Compare version numbers in Objective-C</a></p><p>里面提到的 <code>[versionStrA compare:versionStrB options:NSNumericSearch]</code> 的方案应该是最优雅的方案了。</p><p>但是不理解这个 NSNumericSearch 的具体工作原理就去盲目使用是危险的，今天我就来研究下它的具体工作原理。</p><a id="more"></a><h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h1><p>参照<a href="https://developer.apple.com/documentation/foundation/nsstringcompareoptions/nsnumericsearch" target="_blank" rel="noopener">官方文档</a>里的说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Numbers within strings are compared using numeric value, that is,</span><br><span class="line">Name2.txt &lt; Name7.txt &lt; Name25.txt.</span><br><span class="line"></span><br><span class="line">Numeric comparison only applies to the numerals in the string, not other characters that</span><br><span class="line">would have meaning in a numeric representation such as a negative sign, a comma, or a</span><br><span class="line">decimal point.</span><br></pre></td></tr></table></figure><p>粗略的直译一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在字符串中的数字将被用数值进行比较，就是说，Name2.txt &lt; Name7.txt &lt; Name25.txt。</span><br><span class="line"></span><br><span class="line">数值比较仅仅对字符串中的纯数字（0-9）生效，而不对其它在数字表达中含有意义的字符生效，例如负号，逗号或小数点。</span><br></pre></td></tr></table></figure><p>这段说明略有歧义，导致很多人第一次看的时候被绕晕。例如刚刚那篇 StackOverflow 问答里的 dooleyo 就理解成 <code>&quot;1.2.3&quot;</code> 和 <code>&quot;1.1.12&quot;</code> 进行比较时，会抛弃所有非数字的字符变成 <code>123</code> 和 <code>1112</code> 进行比较，最后得到 <code>&quot;1.2.3&quot; &lt; &quot;1.1.12&quot;</code> 的结论。问答里不少其它朋友也有类似的想法。</p><h1 id="探求真相"><a href="#探求真相" class="headerlink" title="探求真相"></a>探求真相</h1><p>真相只有经过实验才能得到，所以写了一些测试代码来试一下具体的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)testExample &#123;</span><br><span class="line">    [self compareString:@&quot;1.2.3&quot; andString:@&quot;1.1.12&quot;];</span><br><span class="line">    [self compareString:@&quot;1.8&quot; andString:@&quot;1.7.2.3.55&quot;];</span><br><span class="line">    [self compareString:@&quot;1.44&quot; andString:@&quot;1.5&quot;];</span><br><span class="line">    [self compareString:@&quot;7.4.1&quot; andString:@&quot;7.5&quot;];</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">- (void)compareString:(NSString *)stringA andString:(NSString *)stringB &#123;</span><br><span class="line">    NSComparisonResult result = [stringA compare:stringB options:NSNumericSearch];</span><br><span class="line">    switch (result) &#123;</span><br><span class="line">        case NSOrderedDescending:</span><br><span class="line">            NSLog(@&quot;%@ &gt; %@&quot;, stringA, stringB);</span><br><span class="line">            break;</span><br><span class="line">        case NSOrderedAscending:</span><br><span class="line">            NSLog(@&quot;%@ &lt; %@&quot;, stringA, stringB);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            NSLog(@&quot;%@ = %@&quot;, stringA, stringB);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.2.3 &gt; 1.1.12</span><br><span class="line">1.8 &gt; 1.7.2.3.55</span><br><span class="line">1.44 &gt; 1.5</span><br><span class="line">7.4.1 &lt; 7.5</span><br></pre></td></tr></table></figure><p>看上去结果都是正确的，那么看来 <code>NSNumericSearch</code> 并不是粗暴的去掉所有非数字字符后进行数值比对。</p><p>结合原回答里答主说的一句话：<code>keeping in mind that &quot;1&quot; &lt; &quot;1.0&quot; &lt; &quot;1.0.0&quot;</code>，忽然想到了一些什么，继续进行下一步的实验，得到的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1 &lt; 1.0</span><br><span class="line">1.0 &lt; 1.0.0</span><br><span class="line">a10 &lt; b2</span><br><span class="line">a2 &lt; b10</span><br><span class="line">c10 &gt; b2</span><br><span class="line">c2 &gt; b10</span><br><span class="line">2a &lt; 10b</span><br><span class="line">10a &gt; 2b</span><br><span class="line">2c &lt; 10b</span><br><span class="line">10c &gt; 2b</span><br></pre></td></tr></table></figure><p>大家看到这里应该可以猜到官方文档的意思是什么了，其实文档的意思是整个字串<strong>非数字的部分仍然进行常规的字符比较逻辑，只有在遇到数字的时候会把连续的数字转换成数值再进行比对</strong>。具体的比较过程示例参照下图：</p><p><img src="/2019/02/28-A.png" alt="28-A"></p><p>这时候一些奇特的比对结果就可以解释明白了，比如使用这种比较模式会得出 <code>&quot;01&quot; = &quot;1&quot;</code>。</p><h1 id="继续深入"><a href="#继续深入" class="headerlink" title="继续深入"></a>继续深入</h1><p>那么还剩下一个问题，如果和数字字符比较的是非数字字符，会怎么样？我们可以挑一些 ASCII 码在数字字符周围的字符进行试验，结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a/c &lt; a100c</span><br><span class="line">a:c &gt; a100c</span><br><span class="line">a/c &lt; a1c</span><br><span class="line">a:c &gt; a1c</span><br></pre></td></tr></table></figure><p>注意这里出现的部分字符 ASCII 码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/ = 47</span><br><span class="line">0 = 48</span><br><span class="line">1 = 49</span><br><span class="line">...</span><br><span class="line">9 = 57</span><br><span class="line">: = 58</span><br></pre></td></tr></table></figure><p>可以看出现了比较的字符一边是数字，一边是非数字时，是按照常规的 ASCII 码进行比对的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>那么分析到这里就基本结束了，剩下的一些场景类推一下都很容易理解。</p><p>其实在各大 OS 里的文件系统下文件排序用的就是这种比较方法，一开始没有想到这点所以理解上绕了一些弯路。</p><p>用 <code>NSNumericSearch</code> 来进行版本字符串的比对也是十分有效的，不是特殊需要的话就再也不用傻傻的自己分割字符串再分段比较啦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信研究过怎么在 ObjC 中进行版本字符串比对的朋友，大多都看过这一篇 StackOverflow 的问答：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/a/1990854/2562905&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Compare version numbers in Objective-C&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;里面提到的 &lt;code&gt;[versionStrA compare:versionStrB options:NSNumericSearch]&lt;/code&gt; 的方案应该是最优雅的方案了。&lt;/p&gt;
&lt;p&gt;但是不理解这个 NSNumericSearch 的具体工作原理就去盲目使用是危险的，今天我就来研究下它的具体工作原理。&lt;/p&gt;
    
    </summary>
    
      <category term="ObjC" scheme="http://blog.harrisonxi.com/categories/ObjC/"/>
    
    
      <category term="ObjC" scheme="http://blog.harrisonxi.com/tags/ObjC/"/>
    
      <category term="NSNumericSearch" scheme="http://blog.harrisonxi.com/tags/NSNumericSearch/"/>
    
      <category term="NSStringCompareOptions" scheme="http://blog.harrisonxi.com/tags/NSStringCompareOptions/"/>
    
      <category term="NSString" scheme="http://blog.harrisonxi.com/tags/NSString/"/>
    
      <category term="比较" scheme="http://blog.harrisonxi.com/tags/%E6%AF%94%E8%BE%83/"/>
    
      <category term="版本" scheme="http://blog.harrisonxi.com/tags/%E7%89%88%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>EasyReact的简单试用及和RAC的对比</title>
    <link href="http://blog.harrisonxi.com/2018/08/EasyReact%E7%9A%84%E7%AE%80%E5%8D%95%E8%AF%95%E7%94%A8%E5%8F%8A%E5%92%8CRAC%E7%9A%84%E5%AF%B9%E6%AF%94.html"/>
    <id>http://blog.harrisonxi.com/2018/08/EasyReact的简单试用及和RAC的对比.html</id>
    <published>2018-08-15T16:00:00.000Z</published>
    <updated>2018-11-28T06:28:34.757Z</updated>
    
    <content type="html"><![CDATA[<p>美团开源了船新的响应式框架 <a href="https://tech.meituan.com/react_programming_framework_easyreact_opensource.html" target="_blank" rel="noopener">EasyReact</a>，GayHub地址：<a href="https://github.com/meituan/EasyReact" target="_blank" rel="noopener">https://github.com/meituan/EasyReact</a></p><p>作为热爱响应式的程序猿，一定是要试用评测一下这传说中又快又好用的新框架的，事不宜迟我们开始。（虽然这框架已经开源一个月了🙄）</p><a id="more"></a><h1 id="使用-EasyReact-的-MvvmDemo"><a href="#使用-EasyReact-的-MvvmDemo" class="headerlink" title="使用 EasyReact 的 MvvmDemo"></a>使用 EasyReact 的 MvvmDemo</h1><p>评测的具体方案是用我以前的 <a href="http://blog.harrisonxi.com/2017/07/iOS%E4%BD%BF%E7%94%A8RAC%E5%AE%9E%E7%8E%B0MVVM%E7%9A%84%E6%AD%A3%E7%BB%8F%E5%A7%BF%E5%8A%BF.html">MvvmDemo</a> 改造一下，旧 demo 的代码参照 <a href="https://github.com/HarrisonXi/MvvmDemo" target="_blank" rel="noopener">GitHub</a>。使用这个改造的方案，可以更方便的进行 EasyReact 和 RAC 的对比。</p><p>首先进行 EasyReact 的安装，不得不说支持 CocoaPods 的库安装起来还是方便。但是 EasyReact 是没有提供打包好的 Framework 或者对应的 Framework 工程的，这就不太方便进行一次打包多处直接使用二进制包了。</p><table><thead><tr><th>EasyReact 优缺点</th></tr></thead><tbody><tr><td>✅ 支持 CocoaPods</td></tr><tr><td>❌ 没有提供二进制 Framework</td></tr></tbody></table><p>为了方便对比，我把使用 EasyReact 和 RAC 的对比做成了一个独立的 <a href="https://github.com/HarrisonXi/MvvmDemo/commit/0feb1cbc35467fb1e75f3c10199d5987ec2cb573" target="_blank" rel="noopener">commit 0feb1cb</a>。可以看到其实从语法上来说，它们的常规使用方法十分的相似。然后我们来一点点比较细节的差异。</p><h1 id="EZRNode-vs-RACSignal"><a href="#EZRNode-vs-RACSignal" class="headerlink" title="EZRNode vs RACSignal"></a>EZRNode vs RACSignal</h1><p>RACSignal 的设计概念是表示一个可以被订阅的信号流，最主要的意义是表示其内部的值是变化的。而 RACSubject 是表示一个热信号流，热信号和冷信号的内容后面再说，当前主要先要说的 RACSubject 的特征是可以手动发送信号。</p><p>EZRNode 从设计上看上去更像是一个存着 value 的 model，这个使得初学者很容易理解它的用途。而 EZRMutableNode 使得 node 存着的 value 可以被修改，然后修改这个 value 的时候就会对外发出信号。说起来我个人觉得这种设计的确可以让过程式编程的开发者更容易理解和过渡到响应式编程中，但是有点略二不像的设计也会带来对应的困扰。</p><h2 id="1-到底-EZRNode-的-value-是不是可变的"><a href="#1-到底-EZRNode-的-value-是不是可变的" class="headerlink" title="1. 到底 EZRNode 的 value 是不是可变的"></a>1. 到底 EZRNode 的 value 是不是可变的</h2><p>如果我们认为 EZRNode 的 value 是不可变的，那么 EZRNode 提供 <code>listenedBy:</code> 就会很奇怪，一个不可变的值我们监听它干什么呢？</p><p>如果我们认为 EZRNode 的 value 是可变的，那么有些接口的设计又看上去很怪，典型的代表就是响应式编程最常用到的宏定义 <code>EZR_PATH</code> 的实现类 <code>EZRPathTrampoline</code>，在其内部都默认认为 EZRMutableNode 才可以进行绑定。</p><p>我觉得从总体设计上来看，其实应该认为 EZRNode 的 value 值是可变的，<code>EZRNode+Operation.h</code> 中的变换都是基于 EZRNode 来实现的可以证明这一点。另一种理解是哪怕是不可变的值，其实也可以变换和监听的嘛，这样看起来 EZRNode 的意义和 RACSignal 其实是十分接近的。</p><p>另外 <code>EZRPathTrampoline.m</code> 里面有个小细节：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)setObject:(EZRNode *)node forKeyedSubscript:(NSString *)keyPath &#123;</span><br><span class="line">    NSParameterAssert(node);</span><br><span class="line">    NSParameterAssert(keyPath);</span><br><span class="line">    </span><br><span class="line">    EZRMutableNode *keyPathNode = self[keyPath];</span><br><span class="line">    [_cancelBag addCancelable:[keyPathNode syncWith:node]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在头文件里定义的 <code>node</code> 参数是 EZRMutableNode，但是类实现里其实用的是 EZRNode，让我不禁怀疑是不是头文件里的类型写错了……😓</p><p>得出的第一个结论：姑且认为 EZRNode 的意义和 RACSignal 相同，是信号的最基础单元。</p><h2 id="2-EZRNode-还是-EZRMutableNode"><a href="#2-EZRNode-还是-EZRMutableNode" class="headerlink" title="2. EZRNode 还是 EZRMutableNode"></a>2. EZRNode 还是 EZRMutableNode</h2><p>这个问题和问题1其实有点重叠，主要原因的根源还是宏定义 <code>EZR_PATH</code> 的实现类 <code>EZRPathTrampoline</code>。</p><p>对外暴露 EZRNode 类似于对外暴露一个 readonly 的属性，用户表面上可以感知到不可以修改其内部的 value。但是面临的一个问题是，用户想要使用 <code>EZR_PATH</code> 宏进行绑定时还是要进行一次 <code>mutablify</code> 的转换。</p><p>对外直接暴露 EZRMutableNode 的话相当于暴露了一个 readwrite 的属性，用户不仅可以监听它，同时也具备了可以修改其 value 的能力，这对于维持一个 ViewModel 的封装性来说可是个灾难。</p><p>还有一点是，EZRNode 转成 EZRMutableNode 时，复用了原先的内存地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EZRNode *node = [EZRNode new];</span><br><span class="line">EZRMutableNode *mutableNode = [node mutablify];</span><br></pre></td></tr></table></figure><p>上面代码里 <code>node</code> 和 <code>mutableNode</code> 的指针是完全相等的，当然它们的 class 也都会是 EZRMutableNode。这样的好处就是转换前后，它们的逻辑都是连续的；坏处是类型原地转换的逻辑会导致使用方比较混乱（可能前一秒还是 EZRNode 的实例，下一秒就被别人变成 EZRMutableNode 了），另外 <code>mutablify</code> 的转换也是不可逆的。</p><p>这样设计应该也是没有办法：虽然说起来它们和 NSString &amp; NSMutableString 组合有很多相似的地方，但是要支持 copy 协议是很麻烦的。比如想要维持监听的链路不被打断，信号源这种东西在支持 copy 时是很容易出大问题的，要复制要维持的状态多得难以想象。</p><p>综上所诉，我们设计接口时到底是暴露 EZRNode 还是 EZRMutableNode 类型会有很大的困扰。相比较而言，RAC 就没有这个困扰，不想让别人知道这是个可以手动发信号的 RACSubject，包装成 RACSignal 暴露出去就好。其实我还是觉得 EasyReact 去修改下 <code>EZRPathTrampoline</code> 应该也可以达成类似的效果😓。</p><p>不过关于 Node 可变状态的转换的确也没有想到什么好的办法，现在的这个设计模式，即使用 readonly 式的 EZRNode 暴露接口给外界也是形同虚设，毕竟外界拿到这个 EZRNode 之后手动  <code>mutablify</code> 一下，然后想怎么改就怎么改。</p><h2 id="3-冷信号热信号"><a href="#3-冷信号热信号" class="headerlink" title="3. 冷信号热信号"></a>3. 冷信号热信号</h2><p>冷信号一直是 RAC 里面一个让响应式编程新手懵逼的概念，详细的概念我在《<a href="http://blog.harrisonxi.com/2017/09/RAC%E4%B8%AD%E7%9A%84%E5%86%B7%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%83%AD%E4%BF%A1%E5%8F%B7.html">RAC中的冷信号与热信号</a>》中介绍过。</p><p>既然容易让新手懵逼，那么 EasyReact 是怎么处理的呢？EasyReact 里好像就压根没有提供冷信号的概念😂。</p><p>这样倒是也挺好的，让使用者自己基于 block 和各种事件倒是也能完成类似的逻辑，省得新手在理解上有错误而导致写出的代码有严重问题。</p><table><thead><tr><th>EasyReact 优缺点</th></tr></thead><tbody><tr><td>✅ 易理解，抛弃了大量对初学者很晦涩的响应式概念</td></tr><tr><td>❌ 框架内部接口的设计对 EZRNode &amp; EZRMutableNode 的理解貌似本身就不一致</td></tr><tr><td>❌ 不可变和可变 node 的无缝转换过程可能引发其它业务方的逻辑混乱</td></tr><tr><td>❌ EZRNode 完全做不到 readonly 的效果，形同虚设</td></tr><tr><td>⚠️ 抛弃了冷信号的概念，这个优劣参半吧</td></tr></tbody></table><h1 id="宏定义-EZR-PATH"><a href="#宏定义-EZR-PATH" class="headerlink" title="宏定义 EZR_PATH"></a>宏定义 EZR_PATH</h1><p><code>EZR_PATH</code> 宏是和 RAC 中的 <code>RAC</code> &amp; <code>RACObserve</code> 两个宏相同地位的核心宏方法，最大的不同点是它把 RAC 中的两个宏合并成了一个宏。</p><p>这是个好事儿还是坏事儿呢？我个人觉得两面都有。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// RAC</span><br><span class="line">RAC(self.loginButton, enabled) = RACObserve(self.viewModel, loginEnabled);</span><br><span class="line">// EasyReact</span><br><span class="line">EZR_PATH(self.loginButton, enabled) = EZR_PATH(self.viewModel, loginEnabled);</span><br></pre></td></tr></table></figure><p>参照上面的代码示例还有 <code>EZRPathTrampoline</code> 的实现：</p><ol><li>首先我觉得用一个类同时实现监听和被监听两件事，从内聚性上来说讲的过去，可能的确是利大于弊的。</li><li>从代码的阅读和书写上来说，书写只要记住一个宏，写起来会略方便一点点，阅读时也没什么障碍，毕竟一眼就可以看出来是等号左边的表达式监听了等号右边的表达式。</li><li>从工程维护的大角度来说，只用一个宏，很难区分这个宏出现的地方是实现监听者还是被监听者。</li></ol><p>第三点我们拓展开来举个例子，用之前 MvvmDemo 里的代码来看，我想要知道哪些人监听过 ViewModel 的 username 属性，哪些人让 ViewModel 的 username 属性监听过其它信号：</p><p><img src="/2018/08/20-A.png" alt="20-A"></p><p><img src="/2018/08/20-B.png" alt="20-B"></p><p>快速定位，精准无误有木有！只用一个 <code>EZR_PATH</code> 宏的话这些就无法简单精准定位了，写复杂的正则或许能搞定，但是也会麻烦很多。这个需要自行体会，基础架构实现的底层模块的属性，被监听和监听其它属性的信号流多如牛毛，能让定位的复杂度降低是提高工作效率的重要保证。</p><table><thead><tr><th>EasyReact 优缺点</th></tr></thead><tbody><tr><td>⚠️ EZR_PATH 宏易用、二合一，但是也导致难以区分是实现监听者还是被监听者</td></tr></tbody></table><h1 id="对系统类的扩展"><a href="#对系统类的扩展" class="headerlink" title="对系统类的扩展"></a>对系统类的扩展</h1><p>基于刚刚提到的 <a href="https://github.com/HarrisonXi/MvvmDemo/commit/0feb1cbc35467fb1e75f3c10199d5987ec2cb573" target="_blank" rel="noopener">commit 0feb1cb</a> 的 MvvmDemo 是不完整的，一个很重要的原因就是 UITextField 这类 UI 控件，是不可以通过监听它的 text 属性就能简单实现响应式的。所以我们必须要一个新的 <a href="https://github.com/HarrisonXi/MvvmDemo/commit/ad46b53d99920a377de01a4da4f95c44022ef896" target="_blank" rel="noopener">commit ad46b53</a>，来把 UITextField 依然通过 delegate 的方式链接到 ViewModel 上，说起来就是还是抛弃不了过程式的开发方法。</p><p>这点我相信美团内部应该还是有对应的一些封装吧，日后或许也会渐渐开源出来。毕竟如果一套响应式框架如果没有办法很便捷的应用到业务层的 UI 上，实用性就会大打折扣。</p><p>相比较来说沉淀了多年的 RAC 强大的多，不光连 UI 控件的扩展封装很完备，还为了具体的场景需要实现了 RACCommand 和 RACChannel 等类，甚至于连 UserDefaults 都做了对应的扩展封装。</p><table><thead><tr><th>EasyReact 优缺点</th></tr></thead><tbody><tr><td>❌ 没有对系统类的扩展，易用性大打折扣</td></tr></tbody></table><h1 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h1><p>美团官博写着的 EasyReact 还有一个最大的亮点就是性能起飞！不过当然要实践出真知，不能盲目的相信当事人自己的数据。基于上面的 MvvmDemo，我来自己做一个简单的性能对比试验一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)testPerformance &#123;</span><br><span class="line">    [self measureBlock:^&#123;</span><br><span class="line">        TestObject *object = [TestObject new];</span><br><span class="line">        ViewModel *viewModel = [ViewModel new];</span><br><span class="line">        NSArray *array = @[@&quot;0&quot;, @&quot;1&quot;, @&quot;2&quot;, @&quot;3&quot;, @&quot;4&quot;, @&quot;5&quot;, @&quot;6&quot;, @&quot;7&quot;, @&quot;8&quot;, @&quot;9&quot;];</span><br><span class="line">        EZR_PATH(viewModel, username) = EZR_PATH(object, username);</span><br><span class="line">        EZR_PATH(viewModel, password) = EZR_PATH(object, password);</span><br><span class="line">        EZR_PATH(object, usernameColor) = ConvertInputStateToColor(EZR_PATH(viewModel, usernameInputState));</span><br><span class="line">        EZR_PATH(object, passwordColor) = ConvertInputStateToColor(EZR_PATH(viewModel, passwordInputState));</span><br><span class="line">        EZR_PATH(object, loginEnabled) = EZR_PATH(viewModel, loginEnabled);</span><br><span class="line">        for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">            object.username = array[i % 10];</span><br><span class="line">            object.password = array[i % 10];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上单元测试，在 RAC 的分支和 EasyReact 的分支各实现一次，运行完了之后对比总耗时：</p><p><img src="/2018/08/20-C.png" alt="20-C"></p><p>可以看到，在综合了 combine、listen、map 等操作的实验下，EasyReact 的效率在 RAC 的三倍以上。</p><table><thead><tr><th>EasyReact 优缺点</th></tr></thead><tbody><tr><td>✅✅ EasyReact 的效率在 RAC 的三倍以上</td></tr></tbody></table><h1 id="调试复杂度"><a href="#调试复杂度" class="headerlink" title="调试复杂度"></a>调试复杂度</h1><p>EasyReact 的 EZRNode 概念比起 RACSignal 来说，是确确实实的持有了一个 value 的，所以调试起来有相当大的优势。举几个例子：</p><ol><li>可以给 <code>setValue:</code> 加个断点，设置进来的新值和之前的旧值都可以轻松获得。</li><li>任何时机可以方便的直接用 <code>.value</code> 拿到现在的节点值，按照文档描述这个值是线程安全的，放心使用。</li><li>堆栈的深度上及调用的逻辑上看上去<strong>可能</strong>会更简单。</li></ol><p>还有很多其它的可能性，不过这里先展开说一下第3点。下面是同一个单元测试，EasyReact 下的堆栈状态：</p><p><img src="/2018/08/20-D.png" alt="20-D"></p><p>对应的 RAC 下的堆栈状态：</p><p><img src="/2018/08/20-G.png" alt="20-G"></p><p>……</p><p><img src="/2018/08/20-F.png" alt="20-F"></p><p>堆栈长度从22激增到了52（这也是 RAC 效率低一些的重要原因吧🙄）。</p><p>倒是如果把代码隐藏起来（非代码展开，直接使用打包好的 Framework），其实 RAC 的堆栈也会比较清晰：</p><p><img src="/2018/08/20-E.png" alt="20-E"></p><p>可以看到虽然堆栈长度还是很大，但是层级上只展示了几个关键层。</p><p>这种信号流调试起来，说起来谁更方便些真的没有定论，因为毕竟都很麻烦😂。加上跨线程调用的情况，更是难上加难，所以我在这里也就不硬比个高低了。倒是总体说起来 EasyReact 概念简单，设计也简单，应该调试难度肯定会更低一些的。</p><table><thead><tr><th>EasyReact 优缺点</th></tr></thead><tbody><tr><td>✅ EasyReact 调试难度更低</td></tr></tbody></table><h1 id="文档-amp-社区"><a href="#文档-amp-社区" class="headerlink" title="文档 &amp; 社区"></a>文档 &amp; 社区</h1><p>文档也是重要的一点，这里长话短说了。</p><p>RAC 的文档一直是比较差的，这么难的框架还只能靠自己还有零散的博文来啃，的确有些吃力。看 RAC 各种复杂高级变换时，很多时候是借助 ReactiveX 框架的示意图（<a href="http://reactivex.io/documentation/operators/zip.html" target="_blank" rel="noopener">例如这个 zip 的示意图</a>）来理解的，这些示意图很好很强大，学习响应式的朋友也可以去观摩学习下。</p><p>EasyReact 的设计比较简单，文档相对来说就好理解些，而且官方中文文档这点对于国人开发者来说太友好了！</p><p>社区的活跃度这点目前就不清楚会怎样了，国内的社区氛围一直比较差，还不清楚遇到具体的问题时，美团官方的跟进及各大社区的讨论会如何，只能说不抱很大期望。</p><table><thead><tr><th>EasyReact 优缺点</th></tr></thead><tbody><tr><td>✅ 文档齐全，官方中文</td></tr><tr><td>⚠️ 本人个人对社区氛围不抱太大期望</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>老实说光性能这一点，EasyReact 就值得推荐。对于学习响应式框架的初学者来说，EasyReact 是可以尝试的，整体来说它的概念更简单。但是就完备程度来说，EasyReact 还有一段很长的路要走，对 RAC 熟悉程度比较高的程序猿，开发效率肯定还是更高的。所以说从开发效率、运行性能和学习成本等各方面考虑，选择适合你们自己团队的响应式框架吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;美团开源了船新的响应式框架 &lt;a href=&quot;https://tech.meituan.com/react_programming_framework_easyreact_opensource.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;EasyReact&lt;/a&gt;，GayHub地址：&lt;a href=&quot;https://github.com/meituan/EasyReact&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/meituan/EasyReact&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作为热爱响应式的程序猿，一定是要试用评测一下这传说中又快又好用的新框架的，事不宜迟我们开始。（虽然这框架已经开源一个月了🙄）&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://blog.harrisonxi.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://blog.harrisonxi.com/tags/iOS/"/>
    
      <category term="MVVM" scheme="http://blog.harrisonxi.com/tags/MVVM/"/>
    
      <category term="RAC" scheme="http://blog.harrisonxi.com/tags/RAC/"/>
    
      <category term="Reactive Cocoa" scheme="http://blog.harrisonxi.com/tags/Reactive-Cocoa/"/>
    
      <category term="EasyReact" scheme="http://blog.harrisonxi.com/tags/EasyReact/"/>
    
  </entry>
  
  <entry>
    <title>YAML基础语法手册以及和JSON的对照</title>
    <link href="http://blog.harrisonxi.com/2018/07/YAML%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C%E4%BB%A5%E5%8F%8A%E5%92%8CJSON%E7%9A%84%E5%AF%B9%E7%85%A7.html"/>
    <id>http://blog.harrisonxi.com/2018/07/YAML基础语法手册以及和JSON的对照.html</id>
    <published>2018-07-03T16:00:00.000Z</published>
    <updated>2018-09-05T07:31:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://yaml.org/" target="_blank" rel="noopener">YAML</a> 全名 YAML Ain’t Markup Language，主要设计目标是对人类可读性高。<a href="http://yaml.org/spec/1.2/spec.html" target="_blank" rel="noopener">YAML 1.2</a> 是 JSON 的超集，也就是说合法的 JSON 扔给 YAML 1.2 解析器是可以被完美解析的。YAML 集 JSON 和 XML 等各种标记语言之长，进行了扩展强化，功能全面也很易读，很多的系统采用它作为配置文件的格式。</p><a id="more"></a><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fruits:</span><br><span class="line">  - apple1: </span><br><span class="line">      color: red</span><br><span class="line">  - apple2: </span><br><span class="line">      color: green</span><br><span class="line">  - pear</span><br></pre></td></tr></table></figure><p>上面的 YAML 等同于 JSON：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;fruits&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;apple1&quot;: &#123;</span><br><span class="line">        &quot;color&quot;: &quot;red&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">    &#123;</span><br><span class="line">      &quot;apple2&quot;: &#123;</span><br><span class="line">        &quot;color&quot;: &quot;green&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">    &quot;pear&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是看上去简洁了很多，也更容易阅读很多？</p><h1 id="YAML-的基本结构"><a href="#YAML-的基本结构" class="headerlink" title="YAML 的基本结构"></a>YAML 的基本结构</h1><h2 id="缩进符"><a href="#缩进符" class="headerlink" title="缩进符"></a>缩进符</h2><p>YAML 的缩进只能用空格而不能用 tab，一个主要的原因是不同的系统对 tab 的处理不完全一致（比如有的系统把 tab 处理成 4 个空格，有的系统把 tab 处理成 8 个空格）。好在现代的文本编辑器基本都支持把 tab 转换成指定数量的空格。</p><p>YAML 里的元素都是用缩进来匹配层级关系的，简单说就是缩进相同的都是同级元素，缩进比上一个元素长就是上一个元素的子元素。</p><p>具体的例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- apple1:</span><br><span class="line">  color: red</span><br><span class="line">- apple2:</span><br><span class="line">    color: green</span><br></pre></td></tr></table></figure><p>对应的 JSON：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;color&quot;: &quot;red&quot;, </span><br><span class="line">    &quot;apple1&quot;: null</span><br><span class="line">  &#125;, </span><br><span class="line">  &#123;</span><br><span class="line">    &quot;apple2&quot;: &#123;</span><br><span class="line">      &quot;color&quot;: &quot;green&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>请自行体会，我就不展开了。为了方便理解说一下前面的 YAML 等同于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-</span><br><span class="line">  apple1:</span><br><span class="line">  color: red</span><br><span class="line">-</span><br><span class="line">  apple2:</span><br><span class="line">    color: green</span><br></pre></td></tr></table></figure><h2 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h2><p>只要不是行首的缩进符，其它地方的词法分隔符是可以用各种 white space 字符的。但是要注意这是 YAML 1.2 的规则，在 YAML 1.1 里还是严禁用 tab 作分隔符的。我认为 YAML 1.2 做出这样的更改主要也是为了兼容 JSON。目前解析 YAML 的大部分库还是仅支持 YAML 1.1，所以为了兼容性，<strong>分隔符最好还是不要用 tab</strong>。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>YAML 使用 “#” 来进行注释，”#” 及在其之后的当行内容将被忽略。注意 “#” 如果跟在别的元素后面，和元素之间需要用 white space 字符隔开。</p><h2 id="多行文本的种种"><a href="#多行文本的种种" class="headerlink" title="多行文本的种种"></a>多行文本的种种</h2><p>说起来会絮絮叨叨的，懒得说了……请自行看<a href="http://yaml.org/spec/1.2/spec.html#Basic" target="_blank" rel="noopener">官网文档</a>。</p><h1 id="YAML-的纯量（Scalar）"><a href="#YAML-的纯量（Scalar）" class="headerlink" title="YAML 的纯量（Scalar）"></a>YAML 的纯量（Scalar）</h1><p>这就是大部分语言里的基础类型，YAML 里常用的纯量有以下类型：</p><h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><p><code>~</code> / <code>null</code> / <code>Null</code> / <code>NULL</code> 还有空字符都被解析成 null 类型，最标准的写法是 <code>~</code>。</p><h2 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h2><p>最新标准里  <code>y</code> / <code>Y</code> / <code>yes</code> / <code>Yes</code> / <code>YES</code> / <code>n</code> / <code>N</code> / <code>no</code> / <code>No</code> / <code>NO</code> / <code>true</code> / <code>True</code> / <code>TRUE</code> / <code>false</code> / <code>False</code> / <code>FALSE</code> / <code>on</code> / <code>On</code> / <code>ON</code> / <code>off</code> / <code>Off</code> / <code>OFF</code> 全部都会被解析成正确的 bool 类型，为了兼容性比较好建议用 <code>true</code> 和 <code>false</code>。</p><p>举个例子，我使用的在线解析器解析如下 YAML：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- on</span><br><span class="line">- On</span><br><span class="line">- no</span><br><span class="line">- No</span><br><span class="line">- n</span><br><span class="line">- N</span><br></pre></td></tr></table></figure><p>解析出的 JSON：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  true, </span><br><span class="line">  true, </span><br><span class="line">  false, </span><br><span class="line">  false, </span><br><span class="line">  &quot;n&quot;, </span><br><span class="line">  &quot;N&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="int"><a href="#int" class="headerlink" title="int"></a>int</h2><p>很常规就不多介绍了，YAML 支持 8 进制和 16 进制格式的数据，甚至 2 进制和 60 进制。</p><h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><p>支持常规的浮点数，支持科学计数法，还支持无穷大和 NaN。详情可以参考 <a href="http://yaml.org/type/float.html" target="_blank" rel="noopener">tag:yaml.org,2002:float</a>。</p><h2 id="str"><a href="#str" class="headerlink" title="str"></a>str</h2><p>大部分情况下，YAML 里的字串是不需要带引号的，某些容易引起解析歧义的字串可以用引号括起来。</p><p>示例 YAML：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- a b c</span><br><span class="line">- &quot;a b c&quot;</span><br><span class="line">- &apos;a b c&apos;</span><br><span class="line">- &quot;&apos;\&quot;&quot;</span><br><span class="line">- &apos;&apos;&apos;&quot;&apos;</span><br><span class="line">- 123 # 有歧义，会被解析成 int</span><br><span class="line">- &apos;123&apos;</span><br><span class="line">- yes # 有歧义，会被解析成 bool</span><br><span class="line">- &apos;yes&apos;</span><br><span class="line">- a: b # 有歧义，会被解析成 map</span><br><span class="line">- &apos;a: b&apos;</span><br></pre></td></tr></table></figure><p>对应 JSON：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;a b c&quot;, </span><br><span class="line">  &quot;a b c&quot;, </span><br><span class="line">  &quot;a b c&quot;, </span><br><span class="line">  &quot;&apos;\&quot;&quot;, </span><br><span class="line">  &quot;&apos;\&quot;&quot;, </span><br><span class="line">  123, </span><br><span class="line">  &quot;123&quot;, </span><br><span class="line">  true, </span><br><span class="line">  &quot;yes&quot;, </span><br><span class="line">  &#123; &quot;a&quot;: &quot;b&quot; &#125;, </span><br><span class="line">  &quot;a: b&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>顺带说明下双引号会对转义符进行操作，而单引号不会。双引号内包含双引号可以用 <code>\&quot;</code> 来表示，单引号内包含单引号可以用 <code>&#39;&#39;</code> 来表示。</p><h2 id="其它纯量"><a href="#其它纯量" class="headerlink" title="其它纯量"></a>其它纯量</h2><p>其它纯量是很不常用的类型，可以自行查阅<a href="http://yaml.org/type/" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="类型强转"><a href="#类型强转" class="headerlink" title="类型强转"></a>类型强转</h2><p>另外要提一点，YAML 支持类型强转：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 123</span><br><span class="line">- !!str 123</span><br></pre></td></tr></table></figure><p>对应 JSON：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  123, </span><br><span class="line">  &quot;123&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="字典（Mapping）和数组（Sequence）"><a href="#字典（Mapping）和数组（Sequence）" class="headerlink" title="字典（Mapping）和数组（Sequence）"></a>字典（Mapping）和数组（Sequence）</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>字典：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a: b</span><br><span class="line">c: d</span><br></pre></td></tr></table></figure><p>对应 JSON：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;a&quot;: &quot;b&quot;, </span><br><span class="line">  &quot;c&quot;: &quot;d&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- a</span><br><span class="line">- b</span><br></pre></td></tr></table></figure><p>对应 JSON：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;a&quot;, </span><br><span class="line">  &quot;b&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="嵌套使用"><a href="#嵌套使用" class="headerlink" title="嵌套使用"></a>嵌套使用</h2><p>字典的 value 为数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a:</span><br><span class="line">  - b</span><br><span class="line">  - c</span><br><span class="line">d:</span><br><span class="line">  - e</span><br><span class="line">  - f</span><br></pre></td></tr></table></figure><p>对应 JSON：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;a&quot;: [</span><br><span class="line">    &quot;b&quot;, </span><br><span class="line">    &quot;c&quot;</span><br><span class="line">  ], </span><br><span class="line">  &quot;d&quot;: [</span><br><span class="line">    &quot;e&quot;, </span><br><span class="line">    &quot;f&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据的元素为字典：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-</span><br><span class="line">  a: b</span><br><span class="line">- d: e</span><br></pre></td></tr></table></figure><p>对应 JSON：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;a&quot;: &quot;b&quot;</span><br><span class="line">  &#125;, </span><br><span class="line">  &#123;</span><br><span class="line">    &quot;d&quot;: &quot;e&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="类-JSON-的行内写法"><a href="#类-JSON-的行内写法" class="headerlink" title="类 JSON 的行内写法"></a>类 JSON 的行内写法</h2><p>数组有一种类似 JSON 的写法，可以完成行内数组的功能，当然和 JSON 一样写成多行的也可以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a, b]</span><br></pre></td></tr></table></figure><p>对应 JSON：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;a&quot;, </span><br><span class="line">  &quot;b&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>字典也可以用类似 JSON 的方法写成行内的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;a: b&#125;</span><br></pre></td></tr></table></figure><p>对应 JSON：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;a&quot;: &quot;b&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>引用是 YAML 的一个很方便的高级语法，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name: &amp;name Jason</span><br><span class="line">relation:</span><br><span class="line">  - &amp;info</span><br><span class="line">    name: Sara</span><br><span class="line">    age: 23</span><br><span class="line">  - name: *name</span><br><span class="line">    age: 25</span><br><span class="line">    wife: *info</span><br></pre></td></tr></table></figure><p>解析出的对应 JSON：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;relation&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;age&quot;: 23, </span><br><span class="line">      &quot;name&quot;: &quot;Sara&quot;</span><br><span class="line">    &#125;, </span><br><span class="line">    &#123;</span><br><span class="line">      &quot;age&quot;: 25, </span><br><span class="line">      &quot;name&quot;: &quot;Jason&quot;, </span><br><span class="line">      &quot;wife&quot;: &#123;</span><br><span class="line">        &quot;age&quot;: 23, </span><br><span class="line">        &quot;name&quot;: &quot;Sara&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ], </span><br><span class="line">  &quot;name&quot;: &quot;Jason&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到基本的规则就是用 <code>&amp;</code> 声明一个引用，然后在其他地方用 <code>*</code> 进行展开，有点像 c 语言的指针操作。</p><p>引用的部分就是在 <code>&amp;</code> 之后的整个子元素，上面例子里 <code>&amp;name</code> 引用的是 <code>Jason</code>，而 <code>&amp;info</code> 引用的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name: Sara</span><br><span class="line">age: 23</span><br></pre></td></tr></table></figure><p>在后面使用对应的名称展开后就得到了最终的 JSON 内容。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到此 YAML 的基本语法就介绍得差不多了，更多的内容可以参考以下内容来继续深入阅读：</p><p>YAML 官方网站：<a href="http://yaml.org/" target="_blank" rel="noopener">http://yaml.org/</a></p><p>阮一峰 - 《YAML 语言教程》：<a href="http://www.ruanyifeng.com/blog/2016/07/yaml.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/07/yaml.html</a></p><p>YAML 在线解析：<a href="http://yaml-online-parser.appspot.com/" target="_blank" rel="noopener">http://yaml-online-parser.appspot.com/</a></p><p>YAML 合法性校验：<a href="http://www.yamllint.com/" target="_blank" rel="noopener">http://www.yamllint.com/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://yaml.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;YAML&lt;/a&gt; 全名 YAML Ain’t Markup Language，主要设计目标是对人类可读性高。&lt;a href=&quot;http://yaml.org/spec/1.2/spec.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;YAML 1.2&lt;/a&gt; 是 JSON 的超集，也就是说合法的 JSON 扔给 YAML 1.2 解析器是可以被完美解析的。YAML 集 JSON 和 XML 等各种标记语言之长，进行了扩展强化，功能全面也很易读，很多的系统采用它作为配置文件的格式。&lt;/p&gt;
    
    </summary>
    
      <category term="其它" scheme="http://blog.harrisonxi.com/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="语法" scheme="http://blog.harrisonxi.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
      <category term="JSON" scheme="http://blog.harrisonxi.com/tags/JSON/"/>
    
      <category term="YAML" scheme="http://blog.harrisonxi.com/tags/YAML/"/>
    
  </entry>
  
  <entry>
    <title>ObjC的BOOL为什么要用YES、NO而不建议用true、false？</title>
    <link href="http://blog.harrisonxi.com/2018/05/ObjC%E7%9A%84BOOL%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8YES%E3%80%81NO%E8%80%8C%E4%B8%8D%E5%BB%BA%E8%AE%AE%E7%94%A8true%E3%80%81false%EF%BC%9F.html"/>
    <id>http://blog.harrisonxi.com/2018/05/ObjC的BOOL为什么要用YES、NO而不建议用true、false？.html</id>
    <published>2018-05-15T16:00:00.000Z</published>
    <updated>2018-06-05T03:52:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>嗯，昨天给自己挖了个坑，还是早填坑早完事儿，所以今天有了这篇：</p><p>朋友，ObjC 的 BOOL 类型了解一下？</p><p>可能有人告诉你 BOOL 是 <code>signed char</code> 类型的。放在以前，这个答案是对的，但是放在现在就不完全对了。接下来我来给大家一点点解释其中的细节。</p><a id="more"></a><h1 id="ObjC-的-BOOL-到底是什么类型？"><a href="#ObjC-的-BOOL-到底是什么类型？" class="headerlink" title="ObjC 的 BOOL 到底是什么类型？"></a>ObjC 的 BOOL 到底是什么类型？</h1><p>当前我的 Xcode 版本是 9.3.1，BOOL 的定义是这样的（有适当删减）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#if TARGET_OS_OSX || (TARGET_OS_IOS &amp;&amp; !__LP64__ &amp;&amp; !__ARM_ARCH_7K)</span><br><span class="line">#   define OBJC_BOOL_IS_BOOL 0</span><br><span class="line">#else</span><br><span class="line">#   define OBJC_BOOL_IS_BOOL 1</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if OBJC_BOOL_IS_BOOL</span><br><span class="line">    typedef bool BOOL;</span><br><span class="line">#else</span><br><span class="line">#   define OBJC_BOOL_IS_CHAR 1</span><br><span class="line">    typedef signed char BOOL; </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>作为 iPhone 开发者（🙄），可以近似的理解为在 64-bit 设备上 BOOL 实际是 <code>bool</code> 类型，在 32-bit 设备上 BOOL 的实际类型是 <code>signed char</code>。</p><h1 id="YES-NO-是什么？"><a href="#YES-NO-是什么？" class="headerlink" title="YES / NO 是什么？"></a>YES / NO 是什么？</h1><p>那么 <code>YES</code> / <code>NO</code> 又分别是什么值呢？我们看一下具体的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#if __has_feature(objc_bool)</span><br><span class="line">#define YES __objc_yes</span><br><span class="line">#define NO  __objc_no</span><br><span class="line">#else</span><br><span class="line">#define YES ((BOOL)1)</span><br><span class="line">#define NO  ((BOOL)0)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>这里要先看一下 <code>__objc_yes</code> 和 <code>__objc_no</code> 是什么值，我们在 <a href="https://releases.llvm.org/3.1/tools/clang/docs/ObjectiveCLiterals.html" target="_blank" rel="noopener">LLVM 的文档</a>中可以得到答案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The compiler implicitly converts __objc_yes and __objc_no to (BOOL)1 and (BOOL)0. The keywords are used to disambiguate BOOL and integer literals.</span><br></pre></td></tr></table></figure><p><code>__objc_yes</code> 和 <code>__objc_no</code> 其实就是 <code>(BOOL)1</code> 和 <code>(BOOL)0</code>，这么写的原因就是为了消除 BOOL 和整型数的歧义而已。</p><p><code>(BOOL)1</code> 和 <code>(BOOL)0</code> 这个大家应该也都能很容易理解了，其实就是把 1 和 0 强转成了 BOOL 对应的实际类型。</p><p>所以综上所述为了类型的正确对应，在给 BOOL 类型设值时要用 <code>YES</code> / <code>NO</code>。</p><h1 id="true-false-是什么？"><a href="#true-false-是什么？" class="headerlink" title="true / false 是什么？"></a>true / false 是什么？</h1><p>最早的标准 C 语言里是没有 <code>bool</code> 类型的，在 2000 年的 C99 标准里，新增了 <code>_Bool</code> 保留字，并且在 <code>stdbool.h</code> 里定义了 <code>true</code> 和 <code>false</code>。<code>stdbool.h</code> 的内容可以参照<a href="https://clang.llvm.org/doxygen/stdbool_8h_source.html" target="_blank" rel="noopener">这里</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define bool _Bool</span><br><span class="line">#define true 1</span><br><span class="line">#define false 0</span><br></pre></td></tr></table></figure><p>这里只截取了标准 C 语言情况下的定义（C++ 是自带 bool 和 true、false 的）。可以看到这里只是定义了它们的值，但是却没有保证它们的类型，就是说 <code>true</code> / <code>false</code> 其实可以应用在各种数据类型上。</p><p>有些人还提到 <code>TRUE</code> / <code>FALSE</code> 这两个宏定义，它们其实不是某个标准定义里的内容，一般是早年没有标准定义时自定义出来替代 <code>true</code> / <code>false</code> 使用的，大部分情况下他们的定义和 <code>true</code> / <code>false</code> 一致。</p><p>我们可以写一段代码来验证下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOL a = TRUE;</span><br><span class="line">a = true;</span><br><span class="line">a = YES;</span><br></pre></td></tr></table></figure><p>使用 Xcode 的菜单进行预处理，展开宏定义：</p><p><img src="/2018/05/16-A.png" alt="16-A"></p><p>然后我们就可以得到展开后的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOL a = 1;</span><br><span class="line">a = 1;</span><br><span class="line">a = __objc_yes;</span><br></pre></td></tr></table></figure><h1 id="为什么要对-BOOL-用-YES-NO-而不是-true-false？"><a href="#为什么要对-BOOL-用-YES-NO-而不是-true-false？" class="headerlink" title="为什么要对 BOOL 用 YES / NO 而不是 true / false？"></a>为什么要对 BOOL 用 YES / NO 而不是 true / false？</h1><p>可以看到 ObjC 是自己定义了 BOOL 的类型，然后定义了对应要使用的值 <code>YES</code> / <code>NO</code>，理所当然的第一个原因是我们要按照标准来。</p><p>另一方面，既然 ObjC 的 BOOL 使用的不是标准 C 的定义，那么以后这个定义可能还会修改。虽然说概率很低，但是毕竟从上面的代码看就经历了 <code>signed char</code> 到 <code>bool</code> 的一次修改不是么？为了避免这种风险，建议还是要使用 <code>YES</code> / <code>NO</code>。</p><p>在某些情况下，类型不匹配会导致 warning，而 <code>YES</code> / <code>NO</code> 是带类型的，可以保证类型正确，所以建议要用 <code>YES</code> / <code>NO</code>。</p><h1 id="使用-BOOL-类型的注意点"><a href="#使用-BOOL-类型的注意点" class="headerlink" title="使用 BOOL 类型的注意点"></a>使用 BOOL 类型的注意点</h1><p>因为 BOOL 类型在不同设备有不同的表现，所以有一些地方我们要注意。</p><h2 id="不要手贱写-“-YES”-和-“-YES”"><a href="#不要手贱写-“-YES”-和-“-YES”" class="headerlink" title="不要手贱写 “== YES” 和 “!= YES”"></a>不要手贱写 “== YES” 和 “!= YES”</h2><p>在 BOOL 为 <code>bool</code> 类型的时候，只有真假两个值，其实是可以写 “== YES” 和 “!= YES” 的。我们先举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BOOL a = 2;</span><br><span class="line">if (a) &#123;</span><br><span class="line">    NSLog(@&quot;a is YES&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    NSLog(@&quot;a is NO&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (a == YES) &#123;</span><br><span class="line">    NSLog(@&quot;a == YES&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    NSLog(@&quot;a != YES&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 64-bit 设备我们将得到结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a is YES</span><br><span class="line">a == YES</span><br></pre></td></tr></table></figure><p>看上去没什么毛病，完美！</p><p>但是在 32-bit 设备我们将得到结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a is YES</span><br><span class="line">a != YES</span><br></pre></td></tr></table></figure><p>这是为什么呢？因为在 32-bit 设备上 BOOL 是 <code>signed char</code> 类型的。ObjC 对数值类型做 <code>(a)</code> 这种真假判断时为 0 则假、非 0 则真，所以我们可以得到 <code>a is YES</code> 这种结果。但是对数值类型做 <code>(a == YES)</code> 这种判断时逻辑是什么样的，想必不用我说大家也猜到了，代码翻译出来就是类似这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">signed char a = 2;</span><br><span class="line">if (a == (signed char)1) &#123;</span><br><span class="line">    NSLog(@&quot;a == YES&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    NSLog(@&quot;a != YES&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们当然只能得到 <code>a != YES</code> 这样的结果。</p><h2 id="避免把超过-8-bit-的数据强转成-BOOL"><a href="#避免把超过-8-bit-的数据强转成-BOOL" class="headerlink" title="避免把超过 8-bit 的数据强转成 BOOL"></a>避免把超过 8-bit 的数据强转成 BOOL</h2><p>同样在 64-bit 的设备上，也就是 <code>bool</code> 类型上不会有这个问题，但是在 <code>signed char</code> 类型上就会有这个问题。我们先看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int a = 256;</span><br><span class="line">if (a) &#123;</span><br><span class="line">    NSLog(@&quot;a is YES&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    NSLog(@&quot;a is NO&quot;);</span><br><span class="line">&#125;</span><br><span class="line">BOOL b = a;</span><br><span class="line">if (b) &#123;</span><br><span class="line">    NSLog(@&quot;b is YES&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    NSLog(@&quot;b is NO&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 32-bit 设备上输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a is YES</span><br><span class="line">b is NO</span><br></pre></td></tr></table></figure><p>是不是有点魔幻？但是原因也惊人的简单：</p><ul><li><code>a</code> 的二进制值为 00000000 00000000 00000001 00000000</li><li>转换为 <code>signed char</code> 类型的 <code>b</code> 时丢失了高位</li><li><code>b</code> 的二进制值为 00000000</li></ul><p>所以千万不要做这样的蠢事，更常见的例子是一个 C 函数（十分直观）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 正确的用法</span><br><span class="line">bool isDifferent(int a, int b) &#123;</span><br><span class="line">    return a - b;</span><br><span class="line">&#125;</span><br><span class="line">// 错误的用法</span><br><span class="line">signed char isDifferent(int a, int b) &#123;</span><br><span class="line">    return a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>希望今天的介绍可以让你更深入的了解 ObjC 的 BOOL 类型，小心点不要在代码里埋出大 bug 哦。😁</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;嗯，昨天给自己挖了个坑，还是早填坑早完事儿，所以今天有了这篇：&lt;/p&gt;
&lt;p&gt;朋友，ObjC 的 BOOL 类型了解一下？&lt;/p&gt;
&lt;p&gt;可能有人告诉你 BOOL 是 &lt;code&gt;signed char&lt;/code&gt; 类型的。放在以前，这个答案是对的，但是放在现在就不完全对了。接下来我来给大家一点点解释其中的细节。&lt;/p&gt;
    
    </summary>
    
      <category term="ObjC" scheme="http://blog.harrisonxi.com/categories/ObjC/"/>
    
    
      <category term="ObjC" scheme="http://blog.harrisonxi.com/tags/ObjC/"/>
    
      <category term="BOOL" scheme="http://blog.harrisonxi.com/tags/BOOL/"/>
    
      <category term="YES" scheme="http://blog.harrisonxi.com/tags/YES/"/>
    
      <category term="NO" scheme="http://blog.harrisonxi.com/tags/NO/"/>
    
      <category term="true" scheme="http://blog.harrisonxi.com/tags/true/"/>
    
      <category term="false" scheme="http://blog.harrisonxi.com/tags/false/"/>
    
  </entry>
  
  <entry>
    <title>ObjC中的TypeEncodings</title>
    <link href="http://blog.harrisonxi.com/2018/05/ObjC%E4%B8%AD%E7%9A%84TypeEncodings.html"/>
    <id>http://blog.harrisonxi.com/2018/05/ObjC中的TypeEncodings.html</id>
    <published>2018-05-14T16:00:00.000Z</published>
    <updated>2018-06-05T03:52:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考 Apple Developer 官方文档：<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="noopener">Type Encodings</a>，<a href="https://developer.apple.com/documentation/objectivec/objective_c_runtime?language=objc" target="_blank" rel="noopener">Objective-C Runtime</a></p><p>我们在 JSON &lt;-&gt; Dictionary &lt;-&gt; Model 中面临的一个很大的问题就是判断数据需要转换成什么样的类型。好在 ObjC 作为一款动态语言，利用 runtime 可以轻松解决这个问题。再配合转换器和 KVC，就可以轻松把我们解析好的值放进对应 Model 里。今天要给大家介绍的就是这个类型编码（Type Encodings）的具体细节。</p><a id="more"></a><h1 id="ObjC-的-type-encodings-列表"><a href="#ObjC-的-type-encodings-列表" class="headerlink" title="ObjC 的 type encodings 列表"></a>ObjC 的 type encodings 列表</h1><table><thead><tr><th>编码</th><th>意义</th></tr></thead><tbody><tr><td>c</td><td>char 类型</td></tr><tr><td>i</td><td>int 类型</td></tr><tr><td>s</td><td>short 类型</td></tr><tr><td>l</td><td>long 类型，仅用在 32-bit 设备上</td></tr><tr><td>q</td><td>long long 类型</td></tr><tr><td>C</td><td>unsigned char 类型</td></tr><tr><td>I</td><td>unsigned int 类型</td></tr><tr><td>S</td><td>unsigned short 类型</td></tr><tr><td>L</td><td>unsigned long 类型</td></tr><tr><td>Q</td><td>unsigned long long 类型</td></tr><tr><td>f</td><td>float 类型</td></tr><tr><td>d</td><td>double 类型，long double 不被 ObjC 支持，所以也是指向此编码</td></tr><tr><td>B</td><td>bool 或 _Bool 类型</td></tr><tr><td>v</td><td>void 类型</td></tr><tr><td>*</td><td>C 字串（char *）类型</td></tr><tr><td>@</td><td>对象（id）类型</td></tr><tr><td>#</td><td>Class 类型</td></tr><tr><td>:</td><td>SEL 类型</td></tr><tr><td>[array type]</td><td>C 数组类型（注意这不是 NSArray）</td></tr><tr><td>{name=type…}</td><td>结构体类型</td></tr><tr><td>(name=type…)</td><td>联合体类型</td></tr><tr><td>bnum</td><td>位段（bit field）类型用 b 表示，num 表示字节数，这个类型很少用</td></tr><tr><td>^type</td><td>一个指向 type 类型的指针类型</td></tr><tr><td>?</td><td>未知类型</td></tr></tbody></table><h1 id="C-语言基础数据类型的-type-encodings"><a href="#C-语言基础数据类型的-type-encodings" class="headerlink" title="C 语言基础数据类型的 type encodings"></a>C 语言基础数据类型的 type encodings</h1><h2 id="整型和浮点型数据"><a href="#整型和浮点型数据" class="headerlink" title="整型和浮点型数据"></a>整型和浮点型数据</h2><p>简单给大家举个例子，我们先来看看常用的数值类型，用下面的代码来打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;char     : %s, %lu&quot;, @encode(char), sizeof(char));</span><br><span class="line">NSLog(@&quot;short    : %s, %lu&quot;, @encode(short), sizeof(short));</span><br><span class="line">NSLog(@&quot;int      : %s, %lu&quot;, @encode(int), sizeof(int));</span><br><span class="line">NSLog(@&quot;long     : %s, %lu&quot;, @encode(long), sizeof(long));</span><br><span class="line">NSLog(@&quot;long long: %s, %lu&quot;, @encode(long long), sizeof(long long));</span><br><span class="line">NSLog(@&quot;float    : %s, %lu&quot;, @encode(float), sizeof(float));</span><br><span class="line">NSLog(@&quot;double   : %s, %lu&quot;, @encode(double), sizeof(double));</span><br><span class="line">NSLog(@&quot;NSInteger: %s, %lu&quot;, @encode(NSInteger), sizeof(NSInteger));</span><br><span class="line">NSLog(@&quot;CGFloat  : %s, %lu&quot;, @encode(CGFloat), sizeof(CGFloat));</span><br><span class="line">NSLog(@&quot;int32_t  : %s, %lu&quot;, @encode(int32_t), sizeof(int32_t));</span><br><span class="line">NSLog(@&quot;int64_t  : %s, %lu&quot;, @encode(int64_t), sizeof(int64_t));</span><br></pre></td></tr></table></figure><p>在 32-bit 设备上输出日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">char     : c, 1</span><br><span class="line">short    : s, 2</span><br><span class="line">int      : i, 4</span><br><span class="line">long     : l, 4</span><br><span class="line">long long: q, 8</span><br><span class="line">float    : f, 4</span><br><span class="line">double   : d, 8</span><br><span class="line">NSInteger: i, 4</span><br><span class="line">CGFloat  : f, 4</span><br><span class="line">int32_t  : i, 4</span><br><span class="line">int64_t  : q, 8</span><br></pre></td></tr></table></figure><p>大家注意下上面日志里的 <code>long</code> 类型输出结果，然后我们再看下在 64-bit 设备上的输出日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">char     : c, 1</span><br><span class="line">short    : s, 2</span><br><span class="line">int      : i, 4</span><br><span class="line">long     : q, 8</span><br><span class="line">long long: q, 8</span><br><span class="line">float    : f, 4</span><br><span class="line">double   : d, 8</span><br><span class="line">NSInteger: q, 8</span><br><span class="line">CGFloat  : d, 8</span><br><span class="line">int32_t  : i, 4</span><br><span class="line">int64_t  : q, 8</span><br></pre></td></tr></table></figure><p>可以看到 <code>long</code> 的长度变成了 8，而且类型编码也变成 <code>q</code>，这就是表格里那段话的意思。</p><p>所以呢，一般如果想要整形的长度固定且长度能被一眼看出，建议使用例子最后的 <code>int32_t</code> 和 <code>int64_t</code>，尽量少去使用 <code>long</code> 类型。</p><p>然后要提一下 <code>NSInteger</code> 和 <code>CGFloat</code>，这俩都是针对不同 CPU 分开定义的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#if __LP64__ || (TARGET_OS_EMBEDDED &amp;&amp; !TARGET_OS_IPHONE) || TARGET_OS_WIN32 || NS_BUILD_32_LIKE_64</span><br><span class="line">typedef long NSInteger;</span><br><span class="line">#else</span><br><span class="line">typedef int NSInteger;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if defined(__LP64__) &amp;&amp; __LP64__</span><br><span class="line"># define CGFLOAT_TYPE double</span><br><span class="line">#else</span><br><span class="line"># define CGFLOAT_TYPE float</span><br><span class="line">#endif</span><br><span class="line">typedef CGFLOAT_TYPE CGFloat;</span><br></pre></td></tr></table></figure><p>所以他们在 32-bit 设备上长度为 4，在 64-bit 设备上长度为 8，对应类型编码也会有变化。</p><h2 id="布尔数据"><a href="#布尔数据" class="headerlink" title="布尔数据"></a>布尔数据</h2><p>用下面的代码打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;bool     : %s, %lu&quot;, @encode(bool), sizeof(bool));</span><br><span class="line">NSLog(@&quot;_Bool    : %s, %lu&quot;, @encode(_Bool), sizeof(_Bool));</span><br><span class="line">NSLog(@&quot;BOOL     : %s, %lu&quot;, @encode(BOOL), sizeof(BOOL));</span><br><span class="line">NSLog(@&quot;Boolean  : %s, %lu&quot;, @encode(Boolean), sizeof(Boolean));</span><br><span class="line">NSLog(@&quot;boolean_t: %s, %lu&quot;, @encode(boolean_t), sizeof(boolean_t));</span><br></pre></td></tr></table></figure><p>在 32-bit 设备上输出日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bool     : B, 1</span><br><span class="line">_Bool    : B, 1</span><br><span class="line">BOOL     : c, 1</span><br><span class="line">Boolean  : C, 1</span><br><span class="line">boolean_t: i, 4</span><br></pre></td></tr></table></figure><p>在 64-bit 设备上输出日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bool     : B, 1</span><br><span class="line">_Bool    : B, 1</span><br><span class="line">BOOL     : B, 1</span><br><span class="line">Boolean  : C, 1</span><br><span class="line">boolean_t: I, 4</span><br></pre></td></tr></table></figure><p>可以看到我们最常用的 <code>BOOL</code> 类型还真的是有点妖，这个妖一句两句还说不清楚，我在下一篇博客里会介绍一下。在本篇博客里，这个变化倒是对我们解析模型不会产生很大的影响，所以先略过。</p><h2 id="void、指针和数组"><a href="#void、指针和数组" class="headerlink" title="void、指针和数组"></a>void、指针和数组</h2><p>用下面的代码打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;void    : %s, %lu&quot;, @encode(void), sizeof(void));</span><br><span class="line">NSLog(@&quot;char *  : %s, %lu&quot;, @encode(char *), sizeof(char *));</span><br><span class="line">NSLog(@&quot;short * : %s, %lu&quot;, @encode(short *), sizeof(short *));</span><br><span class="line">NSLog(@&quot;int *   : %s, %lu&quot;, @encode(int *), sizeof(int *));</span><br><span class="line">NSLog(@&quot;char[3] : %s, %lu&quot;, @encode(char[3]), sizeof(char[3]));</span><br><span class="line">NSLog(@&quot;short[3]: %s, %lu&quot;, @encode(short[3]), sizeof(short[3]));</span><br><span class="line">NSLog(@&quot;int[3]  : %s, %lu&quot;, @encode(int[3]), sizeof(int[3]));</span><br></pre></td></tr></table></figure><p>在 64-bit 设备上输出日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void    : v, 1</span><br><span class="line">char *  : *, 8</span><br><span class="line">short * : ^s, 8</span><br><span class="line">int *   : ^i, 8</span><br><span class="line">char[3] : [3c], 3</span><br><span class="line">short[3]: [3s], 6</span><br><span class="line">int[3]  : [3i], 12</span><br></pre></td></tr></table></figure><p>在 32-bit 设备上指针类型的长度会变成 4，这个就不多介绍了。</p><p>可以看到只有 C 字串类型比较特殊，会处理成 <code>*</code> 编码，其它整形数据的指针类型还是正常处理的。</p><h2 id="结构体和联合体"><a href="#结构体和联合体" class="headerlink" title="结构体和联合体"></a>结构体和联合体</h2><p>用下面的代码打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;CGSize: %s, %lu&quot;, @encode(CGSize), sizeof(CGSize));</span><br></pre></td></tr></table></figure><p>在 64-bit 设备上输出日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGSize: &#123;CGSize=dd&#125;, 16</span><br></pre></td></tr></table></figure><p>因为 <code>CGSize</code> 内部的字段都是 <code>CGFloat</code> 的，在 64-bit 设备上实际是 <code>double</code> 类型，所以等于号后面是两个 <code>d</code> 编码，总长度是 16。</p><p>联合体的编码格式十分类似，不多赘述。而位段现在用到的十分少，也不介绍了，有兴趣了解位段的可以参考<a href="https://en.wikipedia.org/wiki/Bit_field" target="_blank" rel="noopener">维基百科</a>。</p><h1 id="ObjC-数据类型的-type-encodings"><a href="#ObjC-数据类型的-type-encodings" class="headerlink" title="ObjC 数据类型的 type encodings"></a>ObjC 数据类型的 type encodings</h1><p>ObjC 数据类型大部分情况下要配合 runtime 使用，单独用 <code>@encode</code> 操作符的话，基本上也就能做到下面这些：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;Class   : %s&quot;, @encode(Class));</span><br><span class="line">NSLog(@&quot;NSObject: %s&quot;, @encode(NSObject));</span><br><span class="line">NSLog(@&quot;NSString: %s&quot;, @encode(NSString));</span><br><span class="line">NSLog(@&quot;id      : %s&quot;, @encode(id));</span><br><span class="line">NSLog(@&quot;Selector: %s&quot;, @encode(SEL));</span><br></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class   : #</span><br><span class="line">NSObject: &#123;NSObject=#&#125;</span><br><span class="line">NSString: &#123;NSString=#&#125;</span><br><span class="line">id      : @</span><br><span class="line">Selector: :</span><br></pre></td></tr></table></figure><p>可以看到对象的类名称的编码方式跟结构体相似，等于号后面那个 <code>#</code> 就是 <code>isa</code> 指针了，是一个 <code>Class</code> 类型的数据。</p><h2 id="类属性和成员变量的-type-encodings"><a href="#类属性和成员变量的-type-encodings" class="headerlink" title="类属性和成员变量的 type encodings"></a>类属性和成员变量的 type encodings</h2><p>我们可以用 runtime 去获得类的属性对应的 type encoding：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">objc_property_t property = class_getProperty([NSObject class], &quot;description&quot;);</span><br><span class="line">if (property) &#123;</span><br><span class="line">    NSLog(@&quot;%s - %s&quot;, property_getName(property), property_getAttributes(property));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    NSLog(@&quot;not found&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会获得这么一段输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">description - T@&quot;NSString&quot;,R,C</span><br></pre></td></tr></table></figure><p>这里的 <code>R</code> 表示 <code>readonly</code>，<code>C</code> 表示 <code>copy</code>，这都是属性的修饰词，不过在本篇先不多介绍。</p><p>主要要说的是这里的 <code>T</code>，也就是 <code>type</code>，后面跟的这段 <code>@&quot;NSString&quot;</code> 就是 type encoding 了。可以看到 runtime 比较贴心的用双引号的方式告诉了我们这个对象的实际类型是什么。</p><p>关于属性的修饰词，更多内容可以参考 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html" target="_blank" rel="noopener">Apple 文档</a>。其中 <code>T</code> 段始终会是第一个 attribute，所以处理起来会简单点。</p><p>而如果是成员变量的话，我们可以用类似下面的办法去获得 type encoding：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@interface TestObject : NSObject &#123;</span><br><span class="line">    int testInt;</span><br><span class="line">    NSString *testStr;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">Ivar ivar = class_getInstanceVariable([TestObject class], &quot;testInt&quot;);</span><br><span class="line">if (ivar) &#123;</span><br><span class="line">    NSLog(@&quot;%s - %s&quot;, ivar_getName(ivar), ivar_getTypeEncoding(ivar));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    NSLog(@&quot;not found&quot;);</span><br><span class="line">&#125;</span><br><span class="line">ivar = class_getInstanceVariable([TestObject class], &quot;testStr&quot;);</span><br><span class="line">if (ivar) &#123;</span><br><span class="line">    NSLog(@&quot;%s - %s&quot;, ivar_getName(ivar), ivar_getTypeEncoding(ivar));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    NSLog(@&quot;not found&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获得的输出会是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testInt - i</span><br><span class="line">testStr - @&quot;NSString&quot;</span><br></pre></td></tr></table></figure><p>因为成员变量没有属性修饰词那些，所以直接获得的就是 type encoding，格式和属性的 <code>T</code> attribute 一样。</p><h2 id="类方法的-type-encoding"><a href="#类方法的-type-encoding" class="headerlink" title="类方法的 type encoding"></a>类方法的 type encoding</h2><p>有的时候模型设置数据的方式并不是用属性的方式，而是用方法的方式。我们举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Method method = class_getInstanceMethod([UIView class], @selector(setFrame:));</span><br><span class="line">if (method) &#123;</span><br><span class="line">    NSLog(@&quot;%@ - %s&quot;, NSStringFromSelector(method_getName(method)), method_getTypeEncoding(method));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    NSLog(@&quot;not found&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以获得输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setFrame: - v48@0:8&#123;CGRect=&#123;CGPoint=dd&#125;&#123;CGSize=dd&#125;&#125;16</span><br></pre></td></tr></table></figure><p>输出就是整个类方法的 type encoding，关于这个我没找到官方文档的介绍，所以只能根据自己的推测来介绍这个编码的格式：</p><ul><li>第一个字符 <code>v</code> 是表示函数的返回值是 void 类型</li><li>后续的 <code>48</code> 表示函数参数表的长度（指返回值之后的所有参数，虽然返回值在 runtime 里也算是个参数）</li><li>后续的 <code>@</code> 表示一个对象，在 ObjC 里这里传递的是 <code>self</code>，实例方法是要传递实例对象给函数的</li><li>后续的 <code>0</code> 上面参数对应的 offset</li><li>后续的 <code>:</code> 表示一个 selector，用来指出要调用的函数是哪个</li><li>后续的 <code>8</code> 是 selector 参数的 offset，因为这是跑在 64-bit 设备上的，所以 <code>@</code> 和 <code>:</code> 的长度都是 8</li><li>后续的 <code>{CGRect={CGPoint=dd}{CGSize=dd}}</code> 是 CGRect 结构体的 type encoding，从这里也可以看出结构体嵌套使用时对应的 type encoding 是这种格式的，这个结构体包含 4 个 double 类型的数据，所以总长度应该是 32</li><li>最后的 <code>16</code> 是最后一个参数的 offset，加上刚刚的参数长度 32 正好是整个函数参数表的长度</li></ul><p>我们拿另一个类方法来验证下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Method method = class_getInstanceMethod([UIViewController class], @selector(title));</span><br><span class="line">if (method) &#123;</span><br><span class="line">    NSLog(@&quot;%@ - %s&quot;, NSStringFromSelector(method_getName(method)), method_getTypeEncoding(method));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    NSLog(@&quot;not found&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@16@0:8</span><br></pre></td></tr></table></figure><p>可以看到很可惜，NSString 类型在类方法的 type encoding 里是不会有引号内容的，所以我们只能知道这个参数是个 id 类型。编码的具体解析：</p><ul><li><code>@</code> - 返回 id 类型</li><li><code>16</code> - 参数表总长度</li><li><code>@</code> - 用来传递 <code>self</code>，是 id 类型</li><li><code>0</code> - <code>self</code> 参数的 offset</li><li><code>:</code> - 传递具体要调用哪个方法，selector 类型</li><li><code>8</code> - selector 参数的 offset</li></ul><p>如果是类的静态方法而不是实例方法，我们可以用类似这样的代码获得 Method 结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method method = class_getClassMethod([TestObject class], @selector(testMethod));</span><br></pre></td></tr></table></figure><p>不过说起来这种格式的编码还是不容易解析，所以我们可以用另一种方式直接拿对应位置的参数的编码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Method method = class_getInstanceMethod([UIView class], @selector(setFrame:));</span><br><span class="line">if (method) &#123;</span><br><span class="line">    NSLog(@&quot;%@ - %d&quot;, NSStringFromSelector(method_getName(method)), method_getNumberOfArguments(method));</span><br><span class="line">    NSLog(@&quot;%@ - %s&quot;, NSStringFromSelector(method_getName(method)), method_copyArgumentType(method, 2));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    NSLog(@&quot;not found&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出内容如下，这里是获得了 index 为 2 的参数的编码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setFrame: - 3</span><br><span class="line">setFrame: - &#123;CGRect=&#123;CGPoint=dd&#125;&#123;CGSize=dd&#125;&#125;</span><br></pre></td></tr></table></figure><p>这样就只会获得 type encoding 而不会带上 offset 信息，就容易解析多了。</p><p>另外从这里也可以看到，返回值其实也是算一个参数。</p><h1 id="其它一些-type-encodings-细节"><a href="#其它一些-type-encodings-细节" class="headerlink" title="其它一些 type encodings 细节"></a>其它一些 type encodings 细节</h1><p>还有些 type encodings 的细节和解析模型其实不太相关，不过也在这里介绍一下。</p><h2 id="protocol-类型的-type-encoding"><a href="#protocol-类型的-type-encoding" class="headerlink" title="protocol 类型的 type encoding"></a>protocol 类型的 type encoding</h2><p>用以下代码打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">objc_property_t property = class_getProperty([UIScrollView class], &quot;delegate&quot;);</span><br><span class="line">if (property) &#123;</span><br><span class="line">    NSLog(@&quot;%s - %s&quot;, property_getName(property), property_getAttributes(property));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    NSLog(@&quot;not found&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会获得输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delegate - T@&quot;&lt;UIScrollViewDelegate&gt;&quot;,W,N,V_delegate</span><br></pre></td></tr></table></figure><p>可以看到在属性的 type encoding 里，会用双引号和尖括号表示出 protocol 的类型</p><p>但是去查看方法的话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Method method = class_getInstanceMethod([UIScrollView class], @selector(setDelegate:));</span><br><span class="line">if (method) &#123;</span><br><span class="line">    NSLog(@&quot;%@ - %d&quot;, NSStringFromSelector(method_getName(method)), method_getNumberOfArguments(method));</span><br><span class="line">    NSLog(@&quot;%@ - %s&quot;, NSStringFromSelector(method_getName(method)), method_copyArgumentType(method, 2));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    NSLog(@&quot;not found&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依然还是只能得到这样的编码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setDelegate: - 3</span><br><span class="line">setDelegate: - @</span><br></pre></td></tr></table></figure><p>protocol 类型在模型解析中并没有很大的指导作用，因为我们无法知道具体实现了 protocol 协议的 class 是什么。</p><h2 id="block-类型的-type-encoding"><a href="#block-类型的-type-encoding" class="headerlink" title="block 类型的 type encoding"></a>block 类型的 type encoding</h2><p>直接亮结果吧，获得的 type encoding 是 <code>@?</code>，没有任何参考意义，还好我们做模型解析用不到这个。</p><h2 id="关于方法参数的内存对齐"><a href="#关于方法参数的内存对齐" class="headerlink" title="关于方法参数的内存对齐"></a>关于方法参数的内存对齐</h2><p>对 <code>setEnable:</code> 方法取 type encoding 的话会得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setEnabled: - v20@0:8B16</span><br></pre></td></tr></table></figure><p>可是 bool 的长度明明只有 1 啊，所以这是为什么呢？感兴趣的朋友可以了解下<a href="https://en.wikipedia.org/wiki/Data_structure_alignment" target="_blank" rel="noopener">内存对齐</a>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于 Type Encodings，要讲的差不多就这么多了。暂时没有想到还有什么要补充的，后面想到了再补上来吧。</p><p>希望对大家有帮助，也欢迎大家指正错误或者进行讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考 Apple Developer 官方文档：&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Type Encodings&lt;/a&gt;，&lt;a href=&quot;https://developer.apple.com/documentation/objectivec/objective_c_runtime?language=objc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Objective-C Runtime&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们在 JSON &amp;lt;-&amp;gt; Dictionary &amp;lt;-&amp;gt; Model 中面临的一个很大的问题就是判断数据需要转换成什么样的类型。好在 ObjC 作为一款动态语言，利用 runtime 可以轻松解决这个问题。再配合转换器和 KVC，就可以轻松把我们解析好的值放进对应 Model 里。今天要给大家介绍的就是这个类型编码（Type Encodings）的具体细节。&lt;/p&gt;
    
    </summary>
    
      <category term="ObjC" scheme="http://blog.harrisonxi.com/categories/ObjC/"/>
    
    
      <category term="ObjC" scheme="http://blog.harrisonxi.com/tags/ObjC/"/>
    
      <category term="JSON" scheme="http://blog.harrisonxi.com/tags/JSON/"/>
    
      <category term="Model" scheme="http://blog.harrisonxi.com/tags/Model/"/>
    
      <category term="Type" scheme="http://blog.harrisonxi.com/tags/Type/"/>
    
      <category term="Encoding" scheme="http://blog.harrisonxi.com/tags/Encoding/"/>
    
      <category term="runtime" scheme="http://blog.harrisonxi.com/tags/runtime/"/>
    
      <category term="Property" scheme="http://blog.harrisonxi.com/tags/Property/"/>
    
      <category term="Method" scheme="http://blog.harrisonxi.com/tags/Method/"/>
    
      <category term="属性" scheme="http://blog.harrisonxi.com/tags/%E5%B1%9E%E6%80%A7/"/>
    
      <category term="方法" scheme="http://blog.harrisonxi.com/tags/%E6%96%B9%E6%B3%95/"/>
    
      <category term="模型" scheme="http://blog.harrisonxi.com/tags/%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="类型" scheme="http://blog.harrisonxi.com/tags/%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>在iOS中如何正确的实现行间距与行高</title>
    <link href="http://blog.harrisonxi.com/2018/03/%E5%9C%A8iOS%E4%B8%AD%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%A1%8C%E9%97%B4%E8%B7%9D%E4%B8%8E%E8%A1%8C%E9%AB%98.html"/>
    <id>http://blog.harrisonxi.com/2018/03/在iOS中如何正确的实现行间距与行高.html</id>
    <published>2018-03-25T16:00:00.000Z</published>
    <updated>2018-06-05T03:52:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近准备给 <a href="https://github.com/alibaba/VirtualView-iOS" target="_blank" rel="noopener">VirtualView-iOS</a> 的文本元素新增一个 lineHeight 属性，以便和 <a href="https://github.com/alibaba/Virtualview-Android" target="_blank" rel="noopener">VirtualView-Android</a> 配合时能更精确的保证双平台的一致性。面向 Google 以及 Stack Overflow 编程了一会后发现，能查到的资料大部分是介绍如何实现 lineSpacing 属性，而不是 lineHeight。但是我就是因为 iOS 和 Android 的默认 lineSpacing 不一致所以才想实现个 lineHeight 啊！还是需要自己动手丰衣足食，顺带整理成文章造福后人。</p><a id="more"></a><h1 id="关于行间距-lineSpacing"><a href="#关于行间距-lineSpacing" class="headerlink" title="关于行间距 lineSpacing"></a>关于行间距 lineSpacing</h1><p>先贴出一张 iOS 中 UILabel 的默认排版样式：</p><p><img src="/2018/03/26-A.png" alt="26-A"></p><p>大家也都能看出来，默认的排版样式中，文本的行间距很小，显得文本十分挤。</p><p>这种时候，设计师就会提出行间距的需求，希望让文本展示得更美观。类似的标注就会像这样：</p><p><img src="/2018/03/26-B.png" alt="26-B"></p><p>对于如此合理的要求，我们当然是要支持，<del>特别是设计师还是漂亮小姐姐的情况下</del>。通常来说既然设计师要求的是行间距，那么我们直接设置 lineSpacing 就好。但是 UILabel 是没有这么一个直接暴露的属性的，想要修改 lineSpacing，我们需要借助 NSAttributedString 来实现，示意代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSMutableParagraphStyle *paragraphStyle = [NSMutableParagraphStyle new];</span><br><span class="line">paragraphStyle.lineSpacing = 10;</span><br><span class="line">NSMutableDictionary *attributes = [NSMutableDictionary dictionary];</span><br><span class="line">[attributes setObject:paragraphStyle forKey:NSParagraphStyleAttributeName];</span><br><span class="line">label.attributedText = [[NSAttributedString alloc] initWithString:label.text attributes:attributes];</span><br></pre></td></tr></table></figure><p>运行一下观察效果：</p><p><img src="/2018/03/26-C.png" alt="26-C"></p><p>虽然用我们的眼睛看上去好像没什么问题，但是设计师的火眼金睛一下就能看出来，和设计稿要求的有差距：</p><p><img src="/2018/03/26-D.png" alt="26-D"></p><p>怎么会成这样！？这跟说好的不一样对不对！？不要慌，我来细细解释下。</p><h1 id="正确的实现行间距"><a href="#正确的实现行间距" class="headerlink" title="正确的实现行间距"></a>正确的实现行间距</h1><p>先看示意图：</p><p><img src="/2018/03/26-E.png" alt="26-E"></p><p>红色区域是默认绘制单行文本会占用的区域，可以看到文字的上下是有一些留白的（蓝色和红色重叠的部分）。设计师是想要蓝色区域高度为 10pt，而我们直接设置 lineSpacing 会将两行红色区域中间的绿色区域高度设置为 10pt，这就是问题的根源了。</p><p>那么这个红色的区域高度是多少呢？答案是 <code>label.font.lineHeight</code>，它是使用指定字体绘制单行文本的原始行高。</p><p>知道了原因后问题就好解决了，我们需要在设置 lineSpacing 时，减去这个系统的自带边距：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSMutableParagraphStyle *paragraphStyle = [NSMutableParagraphStyle new];</span><br><span class="line">paragraphStyle.lineSpacing = 10 - (label.font.lineHeight - label.font.pointSize);</span><br><span class="line">NSMutableDictionary *attributes = [NSMutableDictionary dictionary];</span><br><span class="line">[attributes setObject:paragraphStyle forKey:NSParagraphStyleAttributeName];</span><br><span class="line">label.attributedText = [[NSAttributedString alloc] initWithString:label.text attributes:attributes];</span><br></pre></td></tr></table></figure><p>观察一下效果，完美契合（<del>可以在小姐姐面前吹一年</del>）：</p><p><img src="/2018/03/26-F.png" alt="26-F"></p><h1 id="关于行高-lineHeight"><a href="#关于行高-lineHeight" class="headerlink" title="关于行高 lineHeight"></a>关于行高 lineHeight</h1><p>如果你只关心 iOS 设备上的文本展示效果，那么看到这里就已经够了。但是我需要的是 iOS 和 Android 展现出一模一样的效果，所以光有行间距是不能满足需求的。主要的原因在前言也提到了，Android 设备上的文字上下默认留白（上一节图中蓝色和红色重叠的部分）和 iOS 设备上的是不一致的：</p><p><img src="/2018/03/26-G.png" alt="26-G"></p><p>左侧是 iOS 设备，右侧 Android 设备，可以看到同样是显示 20 号的字体，安卓的行高会偏高一些。在不同的 Android 设备上使用的字体不一样，可能还会出现更多的差别。如果不想办法抹平这差别，就不能真正意义上实现双端一致了。</p><p>这时候我们可以通过设置 lineHeight 来使得每一行文本的高度一致，lineHeight 设置为 30pt 的情况下，一行文本高度一定是 30pt，两行文本高度一定是 60pt。虽然文字的渲染上会有细微的差别，但是布局上的差别将被完全的抹除。lineHeight 同样可以借助 NSAttributedString 来实现，示意代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSMutableParagraphStyle *paragraphStyle = [NSMutableParagraphStyle new];</span><br><span class="line">paragraphStyle.maximumLineHeight = lineHeight;</span><br><span class="line">paragraphStyle.minimumLineHeight = lineHeight;</span><br><span class="line">NSMutableDictionary *attributes = [NSMutableDictionary dictionary];</span><br><span class="line">[attributes setObject:paragraphStyle forKey:NSParagraphStyleAttributeName];</span><br><span class="line">label.attributedText = [[NSAttributedString alloc] initWithString:label.text attributes:attributes];</span><br></pre></td></tr></table></figure><p>运行一下观察效果：</p><p><img src="/2018/03/27-A.png" alt="27-A"></p><p>在 debug 模式下确认了下文本的高度的确正确的，但是为什么文字都显示在了行底呢？</p><h1 id="修正行高增加后文字的位置"><a href="#修正行高增加后文字的位置" class="headerlink" title="修正行高增加后文字的位置"></a>修正行高增加后文字的位置</h1><p>修正文字在行中展示的位置，我们可以用 <a href="https://developer.apple.com/documentation/foundation/nsattributedstringkey/1526427-baselineoffset" target="_blank" rel="noopener">baselineOffset</a> 属性来搞定。这个属性十分有用，在实现上标下标之类的需求时也经常用到它。经过调试，发现最合适的值是 <code>(lineHeight - label.font.lineHeight) / 4</code>（尚未搞清楚为什么是除以 4 而不是除以 2，希望知道的老司机指点一二）。最终的代码示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSMutableParagraphStyle *paragraphStyle = [NSMutableParagraphStyle new];</span><br><span class="line">paragraphStyle.maximumLineHeight = lineHeight;</span><br><span class="line">paragraphStyle.minimumLineHeight = lineHeight;</span><br><span class="line">NSMutableDictionary *attributes = [NSMutableDictionary dictionary];</span><br><span class="line">[attributes setObject:paragraphStyle forKey:NSParagraphStyleAttributeName];</span><br><span class="line">CGFloat baselineOffset = (lineHeight - label.font.lineHeight) / 4;</span><br><span class="line">[attributes setObject:@(baselineOffset) forKey:NSBaselineOffsetAttributeName];</span><br><span class="line">label.attributedText = [[NSAttributedString alloc] initWithString:label.text attributes:attributes];</span><br></pre></td></tr></table></figure><p>贴一下在不同字号和行高下的展示效果：</p><p><img src="/2018/03/27-B.png" alt="27-B"></p><h1 id="行高和行间距同时使用时的一个问题"><a href="#行高和行间距同时使用时的一个问题" class="headerlink" title="行高和行间距同时使用时的一个问题"></a>行高和行间距同时使用时的一个问题</h1><p>不得不说行高和行间距我们都已经可以完美的实现了，但是我在尝试同时使用它们时，发现了 iOS 的一个 bug（当然也可能是一个 feature，毕竟不 crash 都不一定是 bug）：</p><p><img src="/2018/03/27-C.png" alt="27-C"></p><p>着色的区域都是文本的绘制区域，其中看上去是橙色的区域是 lineSpacing，绿色的区域是 lineHeight。但是为什么单行的文本系统也要展示一个 lineSpacing 啊！？坑爹呢这是！？</p><p>好在我们通常是行高和行间距针对不同的需求分别独立使用的，它们在分开使用时不会触发这个问题。所以在 <a href="https://github.com/alibaba/VirtualView-iOS" target="_blank" rel="noopener">VirtualView-iOS</a> 库中，我暂且将高度计算的逻辑保持和系统一致了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，成功的为 <a href="https://github.com/alibaba/VirtualView-iOS" target="_blank" rel="noopener">VirtualView-iOS</a> 添加了对 lineHeight 属性的支持，更多的实现细节大家可以到开源库中直接看源代码。希望我们的 Tangram 方案可以更加完善，帮助更多的人一次开发两端同时使用，用一块七巧板拼出大千世界。</p><p>本文首发于<a href="http://pingguohe.net/" target="_blank" rel="noopener">苹果核博客</a>，也是我写的不需要授权😁，但是这个博客名字真不是我起的🙄。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近准备给 &lt;a href=&quot;https://github.com/alibaba/VirtualView-iOS&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;VirtualView-iOS&lt;/a&gt; 的文本元素新增一个 lineHeight 属性，以便和 &lt;a href=&quot;https://github.com/alibaba/Virtualview-Android&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;VirtualView-Android&lt;/a&gt; 配合时能更精确的保证双平台的一致性。面向 Google 以及 Stack Overflow 编程了一会后发现，能查到的资料大部分是介绍如何实现 lineSpacing 属性，而不是 lineHeight。但是我就是因为 iOS 和 Android 的默认 lineSpacing 不一致所以才想实现个 lineHeight 啊！还是需要自己动手丰衣足食，顺带整理成文章造福后人。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://blog.harrisonxi.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://blog.harrisonxi.com/tags/iOS/"/>
    
      <category term="UILabel" scheme="http://blog.harrisonxi.com/tags/UILabel/"/>
    
      <category term="NSAttributedString" scheme="http://blog.harrisonxi.com/tags/NSAttributedString/"/>
    
      <category term="NSParagraphStyle" scheme="http://blog.harrisonxi.com/tags/NSParagraphStyle/"/>
    
      <category term="line spacing" scheme="http://blog.harrisonxi.com/tags/line-spacing/"/>
    
      <category term="line height" scheme="http://blog.harrisonxi.com/tags/line-height/"/>
    
      <category term="行间距" scheme="http://blog.harrisonxi.com/tags/%E8%A1%8C%E9%97%B4%E8%B7%9D/"/>
    
      <category term="行高" scheme="http://blog.harrisonxi.com/tags/%E8%A1%8C%E9%AB%98/"/>
    
  </entry>
  
  <entry>
    <title>2018，新的开始</title>
    <link href="http://blog.harrisonxi.com/2018/02/2018%EF%BC%8C%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B.html"/>
    <id>http://blog.harrisonxi.com/2018/02/2018，新的开始.html</id>
    <published>2018-02-03T16:00:00.000Z</published>
    <updated>2018-06-05T03:52:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>曾经有朋友说我的博客太朴素了，的确是事实……本来朴素只是因为写起来方便，结果后来发现傻瓜式的东西还是坑多啊……花了一个周末的时间搭好了新的博客框架，又花了一个周末的时间对框架修修补补，今天总算是完工了。</p><p>谨以此2018的第一篇博文和这崭新的博客，迎接新的开始。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;曾经有朋友说我的博客太朴素了，的确是事实……本来朴素只是因为写起来方便，结果后来发现傻瓜式的东西还是坑多啊……花了一个周末的时间搭好了新的博客框架，又花了一个周末的时间对框架修修补补，今天总算是完工了。&lt;/p&gt;
&lt;p&gt;谨以此2018的第一篇博文和这崭新的博客，迎接新的开始。
      
    
    </summary>
    
      <category term="随笔" scheme="http://blog.harrisonxi.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>RAC中的冷信号与热信号</title>
    <link href="http://blog.harrisonxi.com/2017/09/RAC%E4%B8%AD%E7%9A%84%E5%86%B7%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%83%AD%E4%BF%A1%E5%8F%B7.html"/>
    <id>http://blog.harrisonxi.com/2017/09/RAC中的冷信号与热信号.html</id>
    <published>2017-09-20T16:00:00.000Z</published>
    <updated>2018-06-05T03:52:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主旨是浅显易懂的讲解下冷热信号的区别和常见的使用误区，所以篇幅所限不会介绍些内部细节。</p><p>如果想要了解的更深入，可以参照William Zang的博文：<a href="http://williamzang.com/blog/2015/08/18/talk-about-reactivecocoas-cold-signal-and-hot-signal/" target="_blank" rel="noopener">细说ReactiveCocoa的冷信号与热信号</a>。</p><p>文中部分内容参考RAC 4.x的文档：<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/v4.2.2/Documentation/DesignGuidelines.md#the-signal-contract" target="_blank" rel="noopener">设计指南</a>、<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/v4.2.2/Documentation/FrameworkOverview.md" target="_blank" rel="noopener">框架概览</a>，但是文章本身是介绍ObjC的RAC 2.5。</p><p>另外和前一篇博文一样，我称呼一组信号叫做<strong>信号流</strong>，单次发送的信号值为<strong>信号</strong>。</p><a id="more"></a><h1 id="热信号流"><a href="#热信号流" class="headerlink" title="热信号流"></a>热信号流</h1><p>热信号流在RAC 3.x以后为Signal，在RAC 2.5中对应RACSubject。</p><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p>所谓热信号流是用来观察一组随时间流逝的事件用的。一般来说它被用作观察执行中（in progress）事件的进度或流程，例如下载事件的进度和流程。</p><p>热信号流有以下特征：</p><ol><li>随信号发出者自己的进度发送信号，创建后即开始工作。</li><li>新增观察者对信号流不产生任何<a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%89%AF%E4%BD%9C%E7%94%A8" target="_blank" rel="noopener">副作用</a>，无论有没有观察者这个信号流都做相同的工作。</li><li>所有观察者都会在同样的时间收到同样的信号。</li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>举个例子，蒸包子大师傅一天的工作就可以成为一个热信号流，而围观大师傅蒸包子的人就是观察者：</p><ol><li>每半小时出笼一次包子，算作发送一次信号。大师傅兢兢业业，早上上班后就开始一直蒸包子。</li><li>有人来围观大师傅蒸包子对大师傅不产生影响，无论有多少人围观大师傅，大师傅都是半小时出笼一次。</li><li>每隔半小时，正在围观的人都能同时看到大师傅出笼一次包子。错过的人就看不到这次的出笼事件。</li></ol><p>可以说，这里的围观者更关注的是大师傅什么时候出笼包子这类事件。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>注意我们先在RACSubject.m里加上一段NSLog来记录发出的事件：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sendNext:(<span class="keyword">id</span>)value &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"RACSubject sendNext: %@"</span>, value);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后写代码模仿上面的例子：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"create RACSubject"</span>);</span><br><span class="line"></span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line">[subject sendNext:<span class="string">@"大师傅上班"</span>];</span><br><span class="line">[[RACScheduler mainThreadScheduler] afterDelay:<span class="number">1.0</span> schedule:^&#123;</span><br><span class="line">    [subject sendNext:<span class="string">@"第一次出笼"</span>];</span><br><span class="line">&#125;];</span><br><span class="line">[[RACScheduler mainThreadScheduler] afterDelay:<span class="number">2.0</span> schedule:^&#123;</span><br><span class="line">    [subject sendNext:<span class="string">@"第二次出笼"</span>];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[[RACScheduler mainThreadScheduler] afterDelay:<span class="number">0.5</span> schedule:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"路人甲开始围观"</span>);</span><br><span class="line">    [subject subscribeNext:^(<span class="built_in">NSString</span> *msg) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"路人甲看到%@"</span>, msg);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[[RACScheduler mainThreadScheduler] afterDelay:<span class="number">1.5</span> schedule:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"路人乙开始围观"</span>);</span><br><span class="line">    [subject subscribeNext:^(<span class="built_in">NSString</span> *msg) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"路人乙看到%@"</span>, msg);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>观察日志：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-21</span> <span class="number">15</span>:<span class="number">26</span>:<span class="number">52.657</span> MvvmDemo[<span class="number">1246</span>:<span class="number">146676</span>] create RACSubject</span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-21</span> <span class="number">15</span>:<span class="number">26</span>:<span class="number">52.658</span> MvvmDemo[<span class="number">1246</span>:<span class="number">146676</span>] RACSubject sendNext: 大师傅上班</span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-21</span> <span class="number">15</span>:<span class="number">26</span>:<span class="number">53.203</span> MvvmDemo[<span class="number">1246</span>:<span class="number">146676</span>] 路人甲开始围观</span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-21</span> <span class="number">15</span>:<span class="number">26</span>:<span class="number">53.658</span> MvvmDemo[<span class="number">1246</span>:<span class="number">146676</span>] RACSubject sendNext: 第一次出笼</span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-21</span> <span class="number">15</span>:<span class="number">26</span>:<span class="number">53.659</span> MvvmDemo[<span class="number">1246</span>:<span class="number">146676</span>] 路人甲看到第一次出笼</span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-21</span> <span class="number">15</span>:<span class="number">26</span>:<span class="number">54.308</span> MvvmDemo[<span class="number">1246</span>:<span class="number">146676</span>] 路人乙开始围观</span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-21</span> <span class="number">15</span>:<span class="number">26</span>:<span class="number">54.856</span> MvvmDemo[<span class="number">1246</span>:<span class="number">146676</span>] RACSubject sendNext: 第二次出笼</span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-21</span> <span class="number">15</span>:<span class="number">26</span>:<span class="number">54.856</span> MvvmDemo[<span class="number">1246</span>:<span class="number">146676</span>] 路人甲看到第二次出笼</span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-21</span> <span class="number">15</span>:<span class="number">26</span>:<span class="number">54.857</span> MvvmDemo[<span class="number">1246</span>:<span class="number">146676</span>] 路人乙看到第二次出笼</span><br></pre></td></tr></table></figure><p>可以看到这完美的诠释了以上热信号流的各种特征。</p><h1 id="冷信号流"><a href="#冷信号流" class="headerlink" title="冷信号流"></a>冷信号流</h1><p>冷信号流在RAC 3.x以后叫做Signal Producers，在RAC 2.5中对应RACSignal。</p><p>注意RACSubject是RACSignal的一个子类，这也是RAC中大家常搞不清冷热信号流的一个重要原因。😂</p><h2 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h2><p>所谓冷信号流是创建一组信号和处理副作用的。它的主要作用是处理一组完整的操作或任务，供用户观察事件<strong>从开始到结束</strong>的整个流程和事件的<strong>结果</strong>。例如处理一整段网络请求相关操作，供用户观察请求的结果是什么。</p><p>冷信号流有以下特征：</p><ol><li>创建时并不立刻开始工作，在被订阅的时候才开始工作。就是说订阅操作本身会对信号流产生作用。</li><li>每个新增的订阅者收到的可能都是不同的，分别独立的信号流。这些信号流的结果也可能不同，因为冷信号流可能包含一些<a href="https://zh.wikipedia.org/wiki/函数副作用" target="_blank" rel="noopener">副作用</a>。</li></ol><h2 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h2><p>举个例子，包子店收银员卖出包子的过程就可以作为一个冷信号流，而每个买包子的顾客就是一个订阅者：</p><ol><li>收银员上班的时候不是立刻就有工作，在一个新的顾客来的时候才会进行卖包子的工作。</li><li>每个顾客买到的包子都是不同的包子（即使馅一样，也是不同的实例）。而因为还有找不开钱，包子卖完了等各种副作用存在，有可能顾客还会买不到包子。</li></ol><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"create RACSignal"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSInteger</span> count = <span class="number">2</span>;</span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        [subscriber sendNext:<span class="string">@"给收银员钱"</span>];</span><br><span class="line">        [subscriber sendNext:<span class="string">@"买到包子"</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [subscriber sendNext:<span class="string">@"没买到包子"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    count--;</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[[RACScheduler mainThreadScheduler] afterDelay:<span class="number">1.0</span> schedule:^&#123;</span><br><span class="line">    [signal subscribeNext:^(<span class="built_in">NSString</span> *msg) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"顾客甲%@"</span>, msg);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[[RACScheduler mainThreadScheduler] afterDelay:<span class="number">2.0</span> schedule:^&#123;</span><br><span class="line">    [signal subscribeNext:^(<span class="built_in">NSString</span> *msg) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"顾客乙%@"</span>, msg);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[[RACScheduler mainThreadScheduler] afterDelay:<span class="number">3.0</span> schedule:^&#123;</span><br><span class="line">    [signal subscribeNext:^(<span class="built_in">NSString</span> *msg) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"顾客丙%@"</span>, msg);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>注意，这里我们用<code>count</code>模拟了一个剩余包子数量的外部值作为<a href="https://zh.wikipedia.org/wiki/函数副作用" target="_blank" rel="noopener">副作用</a>。但是这里没有做多线程保护，各位自己写代码的时候一定要记得做好对应的多线程保护。</p><p>另外要加个NSLog，RACSignal发送信号其实最终是在RACPassthroughSubscriber.m里做的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sendNext:(<span class="keyword">id</span>)value &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"RACSignal sendNext: %@"</span>, value);</span><br><span class="line">    [<span class="keyword">self</span>.innerSubscriber sendNext:value];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察日志：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-21</span> <span class="number">17</span>:<span class="number">09</span>:<span class="number">06.349</span> MvvmDemo[<span class="number">1494</span>:<span class="number">203071</span>] create RACSignal</span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-21</span> <span class="number">17</span>:<span class="number">09</span>:<span class="number">07.351</span> MvvmDemo[<span class="number">1494</span>:<span class="number">203071</span>] RACSignal sendNext: 给收银员钱</span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-21</span> <span class="number">17</span>:<span class="number">09</span>:<span class="number">07.351</span> MvvmDemo[<span class="number">1494</span>:<span class="number">203071</span>] 顾客甲给收银员钱</span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-21</span> <span class="number">17</span>:<span class="number">09</span>:<span class="number">07.351</span> MvvmDemo[<span class="number">1494</span>:<span class="number">203071</span>] RACSignal sendNext: 买到包子</span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-21</span> <span class="number">17</span>:<span class="number">09</span>:<span class="number">07.351</span> MvvmDemo[<span class="number">1494</span>:<span class="number">203071</span>] 顾客甲买到包子</span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-21</span> <span class="number">17</span>:<span class="number">09</span>:<span class="number">08.350</span> MvvmDemo[<span class="number">1494</span>:<span class="number">203071</span>] RACSignal sendNext: 给收银员钱</span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-21</span> <span class="number">17</span>:<span class="number">09</span>:<span class="number">08.351</span> MvvmDemo[<span class="number">1494</span>:<span class="number">203071</span>] 顾客乙给收银员钱</span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-21</span> <span class="number">17</span>:<span class="number">09</span>:<span class="number">08.351</span> MvvmDemo[<span class="number">1494</span>:<span class="number">203071</span>] RACSignal sendNext: 买到包子</span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-21</span> <span class="number">17</span>:<span class="number">09</span>:<span class="number">08.351</span> MvvmDemo[<span class="number">1494</span>:<span class="number">203071</span>] 顾客乙买到包子</span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-21</span> <span class="number">17</span>:<span class="number">09</span>:<span class="number">09.648</span> MvvmDemo[<span class="number">1494</span>:<span class="number">203071</span>] RACSignal sendNext: 没买到包子</span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-21</span> <span class="number">17</span>:<span class="number">09</span>:<span class="number">09.648</span> MvvmDemo[<span class="number">1494</span>:<span class="number">203071</span>] 顾客丙没买到包子</span><br></pre></td></tr></table></figure><p>可以看到一开始创建RACSignal的时候没有触发买包子流程，每有一个新的顾客来就会触发一个新的流程，流程也可能走向不同的结果。</p><h1 id="误用的隐患"><a href="#误用的隐患" class="headerlink" title="误用的隐患"></a>误用的隐患</h1><h2 id="冷信号流容易导致的问题"><a href="#冷信号流容易导致的问题" class="headerlink" title="冷信号流容易导致的问题"></a>冷信号流容易导致的问题</h2><p>冷信号流是用于一对一环境的，为每个订阅者都重新执行一次独立的信号流。因此，冷信号流可能无意中被订阅很多次，重复运行很多次。看下面的代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"触发一次信号流"</span>);</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[[signal flatten] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123; &#125;];</span><br><span class="line">[[signal map:^<span class="keyword">id</span> _Nullable(<span class="keyword">id</span>  _Nullable value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123; &#125;];</span><br></pre></td></tr></table></figure><p>这例子里的RACSignal的<code>flatten</code>和<code>map:</code>等方法其实也是通过订阅原信号流进行转换后再输出的，所以这里是会打印出两次『触发一次信号流』的。这种情况的增多，就更容易导致冷信号流被订阅次数增加。</p><p>在这种前提下，我们就要注意以下情况下不能滥用冷信号流：</p><ol><li>信号体内有耗时的运算逻辑，如多次运行会造成性能问题。</li><li>信号体内逻辑实际上不期望多次运行，如多次运行会出错。</li></ol><p>这时候我们可以用热信号流替代冷信号流，或者将冷信号流通过<code>publish</code>或者<code>multicast:</code>转换成RACMulticastConnection后进行热信号流式的一对多转发。这细节就不在此展开了，只给个示例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RACMulticastConnection *connection = [[RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"触发一次信号流"</span>);</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;] publish];</span><br><span class="line"></span><br><span class="line">[[connection.signal flatten] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123; &#125;];</span><br><span class="line">[[connection.signal map:^<span class="keyword">id</span> _Nullable(<span class="keyword">id</span>  _Nullable value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123; &#125;];</span><br><span class="line"></span><br><span class="line">[connection connect];</span><br></pre></td></tr></table></figure><h2 id="热信号流容易导致的问题"><a href="#热信号流容易导致的问题" class="headerlink" title="热信号流容易导致的问题"></a>热信号流容易导致的问题</h2><p>热信号流的问题就在于后订阅的订阅者可能丢失之前的某些信号，如果确实需要之前的某些信号时，可以使用RACBehaviorSubject或RACReplaySubject来完成。当然要注意的是，使用这两个类的时候，就只能关注信号的值而不能关心信号发生的时间了，因为时间在replay过程中已经被破坏了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总结起来，热信号流就像直播视频，冷信号流就像点播视频。正确的使用它们，是用好RAC的基础。</p><p>大家加油，有问题的欢迎共同讨论哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文主旨是浅显易懂的讲解下冷热信号的区别和常见的使用误区，所以篇幅所限不会介绍些内部细节。&lt;/p&gt;
&lt;p&gt;如果想要了解的更深入，可以参照William Zang的博文：&lt;a href=&quot;http://williamzang.com/blog/2015/08/18/talk-about-reactivecocoas-cold-signal-and-hot-signal/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;细说ReactiveCocoa的冷信号与热信号&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;文中部分内容参考RAC 4.x的文档：&lt;a href=&quot;https://github.com/ReactiveCocoa/ReactiveCocoa/blob/v4.2.2/Documentation/DesignGuidelines.md#the-signal-contract&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;设计指南&lt;/a&gt;、&lt;a href=&quot;https://github.com/ReactiveCocoa/ReactiveCocoa/blob/v4.2.2/Documentation/FrameworkOverview.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;框架概览&lt;/a&gt;，但是文章本身是介绍ObjC的RAC 2.5。&lt;/p&gt;
&lt;p&gt;另外和前一篇博文一样，我称呼一组信号叫做&lt;strong&gt;信号流&lt;/strong&gt;，单次发送的信号值为&lt;strong&gt;信号&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://blog.harrisonxi.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://blog.harrisonxi.com/tags/iOS/"/>
    
      <category term="RAC" scheme="http://blog.harrisonxi.com/tags/RAC/"/>
    
      <category term="Reactive Cocoa" scheme="http://blog.harrisonxi.com/tags/Reactive-Cocoa/"/>
    
      <category term="冷信号" scheme="http://blog.harrisonxi.com/tags/%E5%86%B7%E4%BF%A1%E5%8F%B7/"/>
    
      <category term="热信号" scheme="http://blog.harrisonxi.com/tags/%E7%83%AD%E4%BF%A1%E5%8F%B7/"/>
    
      <category term="RACSignal" scheme="http://blog.harrisonxi.com/tags/RACSignal/"/>
    
      <category term="RACSubject" scheme="http://blog.harrisonxi.com/tags/RACSubject/"/>
    
  </entry>
  
  <entry>
    <title>RAC中用RACCommand处理指令</title>
    <link href="http://blog.harrisonxi.com/2017/09/RAC%E4%B8%AD%E7%94%A8RACCommand%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html"/>
    <id>http://blog.harrisonxi.com/2017/09/RAC中用RACCommand处理指令.html</id>
    <published>2017-09-18T16:00:00.000Z</published>
    <updated>2018-06-05T03:52:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>信号流 - 即RACSignal，一组<code>next</code> / <code>error</code> / <code>completed</code>信号组成，本文称之为信号流。</p><p>发送信号 - <code>sendNext</code> / <code>sendError</code> / <code>sendCompleted</code>，统称为发送信号。</p><p>主流程信号流 - <code>execute:</code>成功执行一次指令产生的指令流程信号流。</p><p>因为将RACSignal也称为信号，容易引起理解的困难，而其通常就是一组信号组成，所以在这里称之为信号流。</p><a id="more"></a><h1 id="RACCommand的用途"><a href="#RACCommand的用途" class="headerlink" title="RACCommand的用途"></a>RACCommand的用途</h1><p>通常来说我们的App中会存在很多UI指令需要等待异步处理完成（比如等待网络请求返回结果），处理这些UI指令时如果我们手动去处理逻辑的话，一般需要完成以下内容：</p><ol><li>保证指令不会在正在执行时被重复执行。</li><li>维护指令是否在执行中的状态，方便外界监视，用来确定是否需要展示loading界面。</li><li>维护指令是否可以执行的状态，方便和外界UI状态进行同步。</li><li>提供执行指令的入口和指令执行的信号流供处理后续逻辑。</li></ol><p>而RACCommand的出现就是为了将以上大部分逻辑封装起来，方便大家使用。</p><h1 id="RACCommand的公开属性和方法"><a href="#RACCommand的公开属性和方法" class="headerlink" title="RACCommand的公开属性和方法"></a>RACCommand的公开属性和方法</h1><h2 id="executionSignals-amp-errors"><a href="#executionSignals-amp-errors" class="headerlink" title="executionSignals &amp; errors"></a>executionSignals &amp; errors</h2><p>在指令成功开始执行后<code>executionSignals</code>会发送一个信号，信号内包含的数据是一个信号流。对，这是一个信号流的信号流，和指针的指针一样绕口。后面介绍内部实现的时候再详细介绍这个属性。</p><p>在指令开始执行但遇到错误时<code>errors</code>会发送一个next信号，信号的数据是一个NSError。这里不能发送error信号，因为发送error信号后这整个信号流就会终止了。</p><h2 id="allowsConcurrentExecution"><a href="#allowsConcurrentExecution" class="headerlink" title="allowsConcurrentExecution"></a>allowsConcurrentExecution</h2><p>是否支持同时多次执行指令，通常来说都会使用默认值NO。在本文里，我们暂不讨论此属性值为YES的情况。</p><h2 id="executing-amp-enabled"><a href="#executing-amp-enabled" class="headerlink" title="executing &amp; enabled"></a>executing &amp; enabled</h2><p><code>executing</code>用来标记指令是否正在运行，通常用于绑定到loading界面的<code>hidden</code>属性上。</p><p><code>enabled</code>用来标记指令是否可以运行，通常用于绑定到UIButton的<code>enabled</code>属性上。</p><p>一般来说以下两种情况下<code>enabled</code>为NO：</p><ol><li>指令禁止同时多次运行，且指令正在运行中时。</li><li>初始化RACCommand时传入了<code>enabledSignal</code>，且<code>enabledSignal</code>返回NO的时候。</li></ol><h2 id="初始化方法-initWithEnabled-signalBlock"><a href="#初始化方法-initWithEnabled-signalBlock" class="headerlink" title="初始化方法 - initWithEnabled:signalBlock:"></a>初始化方法 - initWithEnabled:signalBlock:</h2><p><code>enabledSignal</code>参数在上面提到了，用于控制指令是否可执行。</p><p>而<code>signalBlock</code>参数是为了传递数据和执行指令流程用的，先看一下这个block的类型：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RACSignal&lt;ValueType&gt; * (^)(InputType _Nullable input)</span><br></pre></td></tr></table></figure><p>返回一个信号流，要求输入一个<code>input</code>值。这里返回的信号流就是给之前的<code>executionSignals</code>用的，而这里的输入值就是后面的<code>execute:</code>方法要用的。具体为什么要用这种方式，会在后面的单独章节里介绍。</p><h2 id="执行指令方法-execute"><a href="#执行指令方法-execute" class="headerlink" title="执行指令方法 - execute:"></a>执行指令方法 - execute:</h2><p><code>execute:</code>方法用于执行指令，<code>input</code>用于传递一些自定义的数据，这个输入值可以为空。</p><p>在指令可以执行时，会通过<code>executionSignals</code>发出成功开始执行指令的<strong>主流程信号流</strong>并将之返回，否则会直接返回一个RACErrorSignal，另外在执行指令过程中遇到的错误信号会由<code>errors</code>信号流收集后统一发出。</p><p>如果想要获得单次执行的内部信号流，特别是想要获得信号流里的原始错误，可以从<code>execute:</code>方法的返回值获得对应信号流。</p><h1 id="RACCommand的内部实现"><a href="#RACCommand的内部实现" class="headerlink" title="RACCommand的内部实现"></a>RACCommand的内部实现</h1><h2 id="执行指令方法-execute-1"><a href="#执行指令方法-execute-1" class="headerlink" title="执行指令方法 - execute:"></a>执行指令方法 - execute:</h2><p>细看<code>execute:</code>方法的内部逻辑：</p><ol><li><p>首先判断了现在指令的<code>enabled</code>状态，如果不可运行则会直接返回一个RACErrorSignal后终止。</p><p><code>enabled</code>实时的状态是通过一个内部的<code>immediateEnabled</code>信号流来获得的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_immediateEnabled = [[[[RACSignal</span><br><span class="line">    combineLatest:@[ enabledSignal, moreExecutionsAllowed ]]</span><br><span class="line">    and]</span><br><span class="line">    takeUntil:<span class="keyword">self</span>.rac_willDeallocSignal]</span><br><span class="line">    replayLast];</span><br></pre></td></tr></table></figure><p>可以看到<code>immediateEnabled</code>信号流就是把<code>enabledSignal</code>信号流和<code>moreExecutionsAllowed</code>信号流进行逻辑与计算，在他们都是YES的情况下就会返回『可以运行』。</p><p><code>enabledSignal</code>是外部传入的不用讲解了，所以再来看看<code>moreExecutionsAllowed</code>信号流的实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *moreExecutionsAllowed = [RACSignal</span><br><span class="line">    <span class="keyword">if</span>:[<span class="keyword">self</span>.allowsConcurrentExecutionSubject startWith:@NO]</span><br><span class="line">    then:[RACSignal <span class="keyword">return</span>:@YES]</span><br><span class="line">    <span class="keyword">else</span>:[immediateExecuting not]];</span><br></pre></td></tr></table></figure><p>因为我们之前说了不考虑支持同时多次执行指令，所以这里<code>moreExecutionsAllowed</code>实际上永远返回<code>immediateExecuting</code>的逻辑取反结果，也就是说保证了指令不可以同时多次执行。</p></li><li><p>用初始化时传入的<code>signalBlock</code>创建用于传递指令执行过程的<strong>主流程信号流</strong>，并断言验证确保其不为空。</p></li><li><p>将<strong>主流程信号流</strong>扔到主线程的RACScheduler里去，从注释看出来这样可以保证在<code>executing</code>和<code>enabled</code>信号流变更生效之后，<strong>主流程信号流</strong>才开始真的运作。</p><p>内部其它信号的触发，基本都是通过<code>addedExecutionSignalsSubject</code>这个RACSubject来组织的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.addedExecutionSignalsSubject sendNext:connection.signal];</span><br></pre></td></tr></table></figure><p>可以看到这里也是将刚刚创建的<strong>主流程信号流</strong>当做参数放在了信号里，方便后续的信号管道逻辑取用。</p></li></ol><h2 id="RACSignal的catchTo-方法"><a href="#RACSignal的catchTo-方法" class="headerlink" title="RACSignal的catchTo:方法"></a>RACSignal的catchTo:方法</h2><p>讲内部信号组织之前需要讲解下<code>catchTo:</code>是用来做什么的，这要首先看一下<code>catch:</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)catch:(RACSignal * (^)(<span class="built_in">NSError</span> *error))catchBlock &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(catchBlock != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        RACSerialDisposable *catchDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line"></span><br><span class="line">        RACDisposable *subscriptionDisposable = [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">            [subscriber sendNext:x];</span><br><span class="line">        &#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">            RACSignal *signal = catchBlock(error);</span><br><span class="line">            <span class="built_in">NSCAssert</span>(signal != <span class="literal">nil</span>, <span class="string">@"Expected non-nil signal from catch block on %@"</span>, <span class="keyword">self</span>);</span><br><span class="line">            catchDisposable.disposable = [signal subscribe:subscriber];</span><br><span class="line">        &#125; completed:^&#123;</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">            [catchDisposable dispose];</span><br><span class="line">            [subscriptionDisposable dispose];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;] setNameWithFormat:<span class="string">@"[%@] -catch:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>catch:</code>方法的核心就在于对error信号的处理，参照上面的代码可以看到，<code>catch:</code>方法在原信号流<code>sendError</code>的时候，将对应的NSError通过<code>catchBlock</code>转换成了一个新的信号流并让原订阅者继续订阅。</p><p>参照以下例子：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始信号</span></span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">    [subscriber sendError:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 经过catch:方法将sendError:nil替换为sendNext:@2</span></span><br><span class="line">RACSignal *catchedSignal = [signal catch:^RACSignal * _Nonnull(<span class="built_in">NSError</span> * _Nonnull error) &#123;</span><br><span class="line">    <span class="keyword">return</span> [RACSignal <span class="keyword">return</span>:@<span class="number">2</span>];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出日志</span></span><br><span class="line">[catchedSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"sendNext: %@"</span>, x);</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"sendError"</span>);</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"sendCompleted"</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>最终输出结果如下，其中的错误信号被替换了：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sendNext: <span class="number">1</span></span><br><span class="line">sendNext: <span class="number">2</span></span><br><span class="line">sendCompleted</span><br></pre></td></tr></table></figure><p>而<code>catchTo:</code>又是做什么的，我们来看一下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)catchTo:(RACSignal *)signal &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> catch:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="keyword">return</span> signal;</span><br><span class="line">    &#125;] setNameWithFormat:<span class="string">@"[%@] -catchTo: %@"</span>, <span class="keyword">self</span>.name, signal];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到逻辑很简单，就是预先传入了一个<code>signal</code>，无论收到的<code>sendError</code>传了什么类型的NSError，都直接返回这个<code>signal</code>。</p><p>这样的话上面的例子中间的<code>catch:</code>就可以替换为：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *catchedSignal = [signal catchTo:[RACSignal <span class="keyword">return</span>:@<span class="number">2</span>]];</span><br></pre></td></tr></table></figure><h2 id="内部信号流-amp-初始化方法-initWithEnabled-signalBlock"><a href="#内部信号流-amp-初始化方法-initWithEnabled-signalBlock" class="headerlink" title="内部信号流 &amp; 初始化方法 - initWithEnabled:signalBlock:"></a>内部信号流 &amp; 初始化方法 - initWithEnabled:signalBlock:</h2><p>讲完了<code>catch:</code>系列方法，就可以开始细细讲初始化方法内各种信号的组织了。</p><p>最开始做的都是一些常规的初始化操作，创建内部使用的RACSubject，然后将外部传入的<code>signalBlock</code>存下来。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_executionSignals = [[[<span class="keyword">self</span>.addedExecutionSignalsSubject</span><br><span class="line">    map:^(RACSignal *signal) &#123;</span><br><span class="line">        <span class="keyword">return</span> [signal catchTo:[RACSignal empty]];</span><br><span class="line">    &#125;]</span><br><span class="line">    deliverOn:RACScheduler.mainThreadScheduler]</span><br><span class="line">    setNameWithFormat:<span class="string">@"%@ -executionSignals"</span>, <span class="keyword">self</span>];</span><br></pre></td></tr></table></figure><p>第一个处理的信号流就是供外部使用的<code>executionSignals</code>，将<code>execute:</code>里发出的<strong>主流程信号流</strong>进行了一次<code>catchTo:</code>操作后，再传出供外部使用。这里是为了将<code>sendError</code>统一由后面的<code>errors</code>信号流捕获，所以才需要进行<code>catchTo:</code>操作。在<strong>主流程信号流</strong>进行<code>sendError</code>的时候，NSError会被<code>catchTo:</code>吞掉，而我们重新创建的又是个空信号流，所以外部的订阅者就收不到这个错误信号了。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RACMulticastConnection *errorsConnection = [[[<span class="keyword">self</span>.addedExecutionSignalsSubject</span><br><span class="line">    flattenMap:^(RACSignal *signal) &#123;</span><br><span class="line">        <span class="keyword">return</span> [[signal</span><br><span class="line">            ignoreValues]</span><br><span class="line">            catch:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">                <span class="keyword">return</span> [RACSignal <span class="keyword">return</span>:error];</span><br><span class="line">            &#125;];</span><br><span class="line">    &#125;]</span><br><span class="line">    deliverOn:RACScheduler.mainThreadScheduler]</span><br><span class="line">    publish];</span><br><span class="line"></span><br><span class="line">_errors = [errorsConnection.signal setNameWithFormat:<span class="string">@"%@ -errors"</span>, <span class="keyword">self</span>];</span><br><span class="line">[errorsConnection connect];</span><br></pre></td></tr></table></figure><p>可以看到<code>errors</code>信号的核心就是通过<code>ignoreValues</code>排除<code>sendNext</code>，仅仅获得<code>sendError</code>，然后将<code>sendError</code>转换为发送NSError值的<code>sendNext</code>。</p><p>简单用图片概括下这两个主要的信号流：</p><p><img src="/2017/09/19-A.png" alt="19-A"></p><p>其中蓝色框的本身就是个信号流，也被当做一个信号发送，就是前文说到的『信号流的信号』。</p><p>后面的信号流有的已经讲过了，有的很简单不需要讲解了，我就再重点讲一下这个信号流：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *immediateExecuting = [[[[<span class="keyword">self</span>.addedExecutionSignalsSubject</span><br><span class="line">    flattenMap:^(RACSignal *signal) &#123;</span><br><span class="line">        <span class="keyword">return</span> [[[signal</span><br><span class="line">            catchTo:[RACSignal empty]]</span><br><span class="line">            then:^&#123;</span><br><span class="line">                <span class="keyword">return</span> [RACSignal <span class="keyword">return</span>:@<span class="number">-1</span>];</span><br><span class="line">            &#125;]</span><br><span class="line">            startWith:@<span class="number">1</span>];</span><br><span class="line">    &#125;]</span><br><span class="line">    scanWithStart:@<span class="number">0</span> reduce:^(<span class="built_in">NSNumber</span> *running, <span class="built_in">NSNumber</span> *next) &#123;</span><br><span class="line">        <span class="keyword">return</span> @(running.integerValue + next.integerValue);</span><br><span class="line">    &#125;]</span><br><span class="line">    map:^(<span class="built_in">NSNumber</span> *count) &#123;</span><br><span class="line">        <span class="keyword">return</span> @(count.integerValue &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;]</span><br><span class="line">    startWith:@NO];</span><br></pre></td></tr></table></figure><p>看上去很绕，看着很头大，不过整理成图片后应该好理解的多：</p><p><img src="/2017/09/19-B.png" alt="19-B"></p><p>最后的两步就不再画了，再画要画不下了……😂</p><p>这整个过程的一个主旨就是每次启动一个新的<strong>主流程信号流</strong>，就发送个<code>+1</code>信号，每次一个<strong>主流程信号流</strong>结束，就发送一个<code>-1</code>信号，最后统计计算出现在正在运行的指令流程总个数，判断现在是不是有指令正在执行。是不是了解了思路之后再回头看代码，就清晰无比了。😜</p><h1 id="RACCommand细节探究"><a href="#RACCommand细节探究" class="headerlink" title="RACCommand细节探究"></a>RACCommand细节探究</h1><p>虽然内部代码也都看懂了，可是有些地方为什么要设计成这样还是值得探究的。</p><h2 id="为什么一定要使用『主流程信号流』的形式"><a href="#为什么一定要使用『主流程信号流』的形式" class="headerlink" title="为什么一定要使用『主流程信号流』的形式"></a>为什么一定要使用『主流程信号流』的形式</h2><p>很多人要问，为什么不是直接发送一个执行成功或一个执行失败两种信号就可以了。</p><p>这里要说下执行的流程，这个流程不一定是单步的，所以使用RACCommand的时候是需要了解每一步执行的情况的。比如以下载文件为例：整个流程可能分为获得文件地址列表，逐个下载文件，全部下载完成，下载失败等各种步骤和状态。</p><p>这种时候每一个单独的执行流程就作为一个整体封装起来就更合理，而封装『流程』最合适的当然就是信号流了。</p><h2 id="为什么要单独封装errors信号流"><a href="#为什么要单独封装errors信号流" class="headerlink" title="为什么要单独封装errors信号流"></a>为什么要单独封装errors信号流</h2><p>这样可以使得我们处理问题时更专注，在<code>executionSignals</code>信号流里只处理流程状态相关的逻辑，在<code>errors</code>信号流里专注于各种错误的处理。</p><p>当然不得不承认这在某些情况下也会带来问题：比如某些流程状态和错误状态很强相关的场景下，可能将代码写在一起反而会更容易理解。不过总体来说目前的设计更为通用一点。</p><p>另外一个重点是这样可以保证<code>executionSignals</code>能使用<code>switchToLatest</code>方法。这个后文会介绍。</p><h2 id="为什么主流程信号流执行时还需要一个input参数"><a href="#为什么主流程信号流执行时还需要一个input参数" class="headerlink" title="为什么主流程信号流执行时还需要一个input参数"></a>为什么主流程信号流执行时还需要一个input参数</h2><p>这个一定意义上来说和UIButton的点击事件<code>- (void)clickAction:(id)sender</code>为什么需要<code>sender</code>差不多。</p><p>展开来说的话就是函数需要消除<a href="https://zh.wikipedia.org/zh-hans/%E5%87%BD%E6%95%B0%E5%89%AF%E4%BD%9C%E7%94%A8" target="_blank" rel="noopener">副作用</a>成为纯函数，所以我们的<strong>主流程信号流</strong>也要具有这个特性，使得每一次的执行流程更独立。</p><p>通常来说这个<code>input</code>是用来区分调用者的，当然也可以用来传递一些其它的关键参数。</p><h1 id="RACCommand的实际使用"><a href="#RACCommand的实际使用" class="headerlink" title="RACCommand的实际使用"></a>RACCommand的实际使用</h1><h2 id="UIButton的RACCommand扩展"><a href="#UIButton的RACCommand扩展" class="headerlink" title="UIButton的RACCommand扩展"></a>UIButton的RACCommand扩展</h2><p>了解完了RACCommand的原理，现在要看一下怎么实际使用它。一般来说用它用的最多的就是UIButton了。</p><p>UIButton的RACCommand扩展主要做了以下三件事：</p><ol><li>扩展新的属性<code>rac_command</code>。</li><li>自动将UIButton的<code>enabled</code>状态绑定到RACCommand的<code>enabled</code>信号上，并在重新设置<code>rac_command</code>的时候正确处理销毁和重新绑定操作。</li><li>在按钮的点击事件中触发RACCommand的<code>execute:</code>方法，将按钮自身当做<code>input</code>参数传入。</li></ol><p>可见做的事情都简单干脆，这样在我们把RACCommand设置给UIButton之后，基本上就不再需要额外为UIButton写逻辑了。这也是RAC的一个主旨，就是让我们在Controller层写尽量少的东西。</p><h2 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h2><p>首先奉上<a href="https://github.com/HarrisonXi/MvvmDemo/releases/tag/RACCommand" target="_blank" rel="noopener">完整代码</a>，这是基于之前的一个MvvmDemo工程继续做的。</p><p>接着来看一下细节代码，首先是ViewModel里的RACCommand实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.loginCommand = [[RACCommand alloc] initWithEnabled:RACObserve(<span class="keyword">self</span>, loginEnabled) signalBlock:^RACSignal * _Nonnull(<span class="keyword">id</span>  _Nullable input) &#123;</span><br><span class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:<span class="string">@"start"</span>];</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1.0</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            @strongify(<span class="keyword">self</span>);</span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span>.password isEqualToString:<span class="string">@"123456789"</span>]) &#123;</span><br><span class="line">                [subscriber sendNext:<span class="string">@"success"</span>];</span><br><span class="line">                [subscriber sendCompleted];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                [subscriber sendError:<span class="literal">nil</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>创建一个新的RACCommand，使用ViewModel的<code>loginEnabled</code>属性来控制RACCommand的<code>enabled</code>状态。</p><p>在内部创建一个<strong>冷信号流</strong>来模拟登录指令的流程，在一秒的延时后判断下密码是否符合条件，来决定是发出错误信号，还是发出登录成功及完成信号。</p><p>ViewController这一侧的代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.loginButton.rac_command = <span class="keyword">self</span>.viewModel.loginCommand;</span><br><span class="line">[<span class="keyword">self</span>.viewModel.loginCommand.executionSignals subscribeNext:^(RACSignal&lt;<span class="keyword">id</span>&gt; * executionSignal) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"get signal: %@"</span>, executionSignal);</span><br><span class="line">    [executionSignal subscribeNext:^(<span class="built_in">NSString</span> *step) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"get step: %@"</span>, step);</span><br><span class="line">    &#125; completed:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"get completed."</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line">[<span class="keyword">self</span>.viewModel.loginCommand.errors subscribeNext:^(<span class="built_in">NSError</span> * error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"get error."</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>首先进行<code>loginButton</code>的<code>rac_command</code>简单设定，然后订阅各种信号做出对应的UI反馈交互。示例中就没有写具体的UI交互了，都是用NSLog直接输出了日志。</p><h2 id="关于switchToLatest"><a href="#关于switchToLatest" class="headerlink" title="关于switchToLatest"></a>关于switchToLatest</h2><p>因为各处看到的博客都推荐使用<code>switchToLatest</code>，但是貌似很少有博客介绍它的细节，所以还是要在此讲清楚以免各位用出大问题。</p><p><code>switchToLatest</code>只能作用于信号流的信号流，它的主要作用：</p><ol><li>每当父信号流发出一个新的子信号流时，就开始转发最新子信号流的<code>sendNext</code>和<code>sendError</code>。</li><li>当父信号流和最后一个子信号流都结束时，<code>sendCompleted</code>。</li></ol><p>从第一条就可以看出来，为什么要把RACCommand的<code>errors</code>信号流单独拎出来了。</p><p>然后列举一个信号流的示例图：</p><p><img src="/2017/09/19-C.png" alt="19-C"></p><p>如图所示，在子信号流的流程有并行的重叠时间时，<code>switchToLatest</code>是会丢失信号的。所以切记，在支持同时多次运行的RACCommand里，千万别用<code>switchToLatest</code>来处理<code>executionSignals</code>。而通常情况下我们用到的RACCommand都是不支持同时多次运行的，放心大胆的用<code>switchToLatest</code>就好。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>新的一篇RAC教程也就到此结束了，赶紧试试用RACCommand把你的指令们封装得更优雅吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;信号流 - 即RACSignal，一组&lt;code&gt;next&lt;/code&gt; / &lt;code&gt;error&lt;/code&gt; / &lt;code&gt;completed&lt;/code&gt;信号组成，本文称之为信号流。&lt;/p&gt;
&lt;p&gt;发送信号 - &lt;code&gt;sendNext&lt;/code&gt; / &lt;code&gt;sendError&lt;/code&gt; / &lt;code&gt;sendCompleted&lt;/code&gt;，统称为发送信号。&lt;/p&gt;
&lt;p&gt;主流程信号流 - &lt;code&gt;execute:&lt;/code&gt;成功执行一次指令产生的指令流程信号流。&lt;/p&gt;
&lt;p&gt;因为将RACSignal也称为信号，容易引起理解的困难，而其通常就是一组信号组成，所以在这里称之为信号流。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://blog.harrisonxi.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://blog.harrisonxi.com/tags/iOS/"/>
    
      <category term="RAC" scheme="http://blog.harrisonxi.com/tags/RAC/"/>
    
      <category term="Reactive Cocoa" scheme="http://blog.harrisonxi.com/tags/Reactive-Cocoa/"/>
    
      <category term="指令" scheme="http://blog.harrisonxi.com/tags/%E6%8C%87%E4%BB%A4/"/>
    
      <category term="RACCommand" scheme="http://blog.harrisonxi.com/tags/RACCommand/"/>
    
  </entry>
  
  <entry>
    <title>RAC中用RACChannel实现双向绑定</title>
    <link href="http://blog.harrisonxi.com/2017/07/RAC%E4%B8%AD%E7%94%A8RACChannel%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A.html"/>
    <id>http://blog.harrisonxi.com/2017/07/RAC中用RACChannel实现双向绑定.html</id>
    <published>2017-07-26T16:00:00.000Z</published>
    <updated>2018-06-05T03:52:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="尝试直接用RACSignal实现双向绑定"><a href="#尝试直接用RACSignal实现双向绑定" class="headerlink" title="尝试直接用RACSignal实现双向绑定"></a>尝试直接用RACSignal实现双向绑定</h1><p>在某些场景下，我们需要把两个数据相互绑定，A的改动影响B，B的改动也影响A。</p><p>为了表现上容易观察，我们先假设有一个同步两个文本框输入内容的需求。</p><a id="more"></a><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RAC(<span class="keyword">self</span>.textFieldA, text) = <span class="keyword">self</span>.textFieldB.rac_textSignal;</span><br><span class="line">RAC(<span class="keyword">self</span>.textFieldB, text) = <span class="keyword">self</span>.textFieldA.rac_textSignal;</span><br></pre></td></tr></table></figure><p>实现两个文本框，用上面的代码相互绑定，然后观看效果：</p><p><img src="/2017/07/26-A.gif" alt="26-A"></p><p>可以看到所得到的效果和我们想要的是一致的。但是这只是一个比较凑巧的案例，因为UITextField的<code>rac_textSignal</code>监视的其实是UI事件：</p><p><img src="/2017/07/26-B.png" alt="26-B"></p><p>在UITextField的<code>text</code>属性改变时，不会触发<code>rac_textSignal</code>。所以在A-&gt;B的信号影响了B的<code>text</code>时，不会触发B-&gt;A的信号。</p><h1 id="对通常的数据用RACSignal实现双向绑定会出现的问题"><a href="#对通常的数据用RACSignal实现双向绑定会出现的问题" class="headerlink" title="对通常的数据用RACSignal实现双向绑定会出现的问题"></a>对通常的数据用RACSignal实现双向绑定会出现的问题</h1><p>而对于通常的数据来说进行双向绑定就会出错，代码和错误直接一图流甩出来先：</p><p><img src="/2017/07/26-C.png" alt="26-C"></p><p>看一眼错误的根源：</p><p><img src="/2017/07/26-D.png" alt="26-D"></p><p>可以看到这里出错的原因就是调用堆栈溢出了。因为双向绑定完成后，A的改动影响了B，然后B的改动又会影响A，形成了一个信号循环：</p><p><img src="/2017/07/26-F.png" alt="26-F"></p><p>打破这个循环的方法也很简单，在信号订阅的block体内进行数据改动时，想办法不发出信号：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@weakify(<span class="keyword">self</span>);</span><br><span class="line">[RACObserve(<span class="keyword">self</span>, a) subscribeNext:^(<span class="built_in">NSString</span> *x) &#123;</span><br><span class="line">    @strongify(<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">self</span>-&gt;_b = x;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"A-&gt;B: %@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[RACObserve(<span class="keyword">self</span>, b) subscribeNext:^(<span class="built_in">NSString</span> *x) &#123;</span><br><span class="line">    @strongify(<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">self</span>-&gt;_a = x;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"B-&gt;A: %@"</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>在这里我们使用成员变量去修改A和B就可以了，完美搞定。</p><p>但是这不是万能的，存在很多缺陷：</p><ol><li>没办法使用<code>RAC(self, a) = RACObserve(self, b);</code>这样优雅的写法了。</li><li>访问不到内部成员变量的时候，没有办法这样写。</li><li>如果为了这个需求来暴露内部成员变量，也是很不明智的行为，会破坏ViewModel的稳定性和封装性。</li></ol><h1 id="RACChannel的出现"><a href="#RACChannel的出现" class="headerlink" title="RACChannel的出现"></a>RACChannel的出现</h1><p>在这个时候，RACChannel就随需要出现了。</p><h2 id="RACChannelTerminal简介"><a href="#RACChannelTerminal简介" class="headerlink" title="RACChannelTerminal简介"></a>RACChannelTerminal简介</h2><p>当然看RACChannel要先看RACChannelTerminal，RACChannelTerminal它是一个RACSignal同时也是一个RACSubscriber，就是说它能发出信号也能订阅信号。我们之后称呼它为终端，它在初始化的时候传入了两个值：</p><ol><li><code>values</code>：终端自己对应的RACReplaySubject（作为RACSignal使用）。外部订阅终端时订阅的实际上是<code>values</code>。</li><li><code>otherTerminal</code>：另一个终端对应的RACReplaySubject（作为RACSubscriber使用），终端在订阅外部信号后会把收到的信号都转发给<code>otherTerminal</code>。</li></ol><h2 id="RACReplaySubject简介"><a href="#RACReplaySubject简介" class="headerlink" title="RACReplaySubject简介"></a>RACReplaySubject简介</h2><p>RACReplaySubject是一种特殊的RACSubject，它可以向新的订阅者重新发送一遍之前所发过的信号。初始化RACReplaySubject的时候会要求设置一个<code>capacity</code>，默认值为NSUIntegerMax，RACReplaySubject会replay最多<code>capacity</code>个发过的<code>next</code>信号。值得注意的是，<code>completed</code>和<code>error</code>信号是始终会replay的，和<code>capacity</code>设置的大小无关。</p><h2 id="RACChannel代码解析"><a href="#RACChannel代码解析" class="headerlink" title="RACChannel代码解析"></a>RACChannel代码解析</h2><p>我们回过头来看RACChannel的完整代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RACChannel</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don't want any starting value from the leadingSubject, but we do want</span></span><br><span class="line">    <span class="comment">// error and completion to be replayed.</span></span><br><span class="line">    RACReplaySubject *leadingSubject = [[RACReplaySubject replaySubjectWithCapacity:<span class="number">0</span>] setNameWithFormat:<span class="string">@"leadingSubject"</span>];</span><br><span class="line">    RACReplaySubject *followingSubject = [[RACReplaySubject replaySubjectWithCapacity:<span class="number">1</span>] setNameWithFormat:<span class="string">@"followingSubject"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Propagate errors and completion to everything.</span></span><br><span class="line">    [[leadingSubject ignoreValues] subscribe:followingSubject];</span><br><span class="line">    [[followingSubject ignoreValues] subscribe:leadingSubject];</span><br><span class="line"></span><br><span class="line">    _leadingTerminal = [[[RACChannelTerminal alloc] initWithValues:leadingSubject otherTerminal:followingSubject] setNameWithFormat:<span class="string">@"leadingTerminal"</span>];</span><br><span class="line">    _followingTerminal = [[[RACChannelTerminal alloc] initWithValues:followingSubject otherTerminal:leadingSubject] setNameWithFormat:<span class="string">@"followingTerminal"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>首先RACChannel创建了两个RACReplaySubject，这是内部的数据通信管道主要组件。</p><p>其中<code>followingSubject</code>的<code>capacity</code>为1，表示会replay最后一次的信号。因为<code>followingSubject</code>是供外部订阅用的，所以首次被订阅时需要给外部一个初始值。</p><p>然后这两个RACReplaySubject相互监视了对方的<code>completed</code>和<code>error</code>信号（<code>ignoreValues</code>用于排除<code>next</code>信号），这是为了保证两个Subject始终同步，不会其中一个已经终止了另一个还在工作。</p><p>最后创建了两个终端将这两个Subject相互绑定，终端所做的工作图示如下：</p><p><img src="/2017/07/27-A.png" alt="27-A"></p><p>总体看下来，RACChannel的设计思想上就是提供两个终端，每个终端各有一个输入口和一个输出口，一个终端负责和内部数据绑定，一个终端暴露出来供外部数据绑定。上图把外部订阅者和外部信号源分开来写，表示它们可能是不同的对象，当然它们也可以是相同的对象（如另一个RACChannel的终端）。一般来说封装好的供使用的RACChannel会将其中一个终端在内部处理好，暴露另一端供使用者进行输入和输出的绑定。</p><h2 id="RACChannel尚难直接使用"><a href="#RACChannel尚难直接使用" class="headerlink" title="RACChannel尚难直接使用"></a>RACChannel尚难直接使用</h2><p>这么看下来，是不是创建个RACChannel，把四个口绑定好就可以双向传输数据了？试一试：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RACChannel *channel = [RACChannel new];</span><br><span class="line">RAC(<span class="keyword">self</span>, a) = channel.leadingTerminal;</span><br><span class="line">[RACObserve(<span class="keyword">self</span>, a) subscribe:channel.leadingTerminal];</span><br><span class="line">RAC(<span class="keyword">self</span>, b) = channel.followingTerminal;</span><br><span class="line">[RACObserve(<span class="keyword">self</span>, b) subscribe:channel.followingTerminal];</span><br></pre></td></tr></table></figure><p>然后，你会再次得到调用堆栈溢出的错误。😂</p><p>因为RACChannel只是实现了双向绑定的设计思想，并没有帮我们处理循环调用的问题。我们在使用RACChannel的时候一般是需要使用它的子类，或者自己设计好代码在某条信号通路上进行打断。</p><h1 id="RACKVOChannel"><a href="#RACKVOChannel" class="headerlink" title="RACKVOChannel"></a>RACKVOChannel</h1><p>看了那么多代码和原理，是时候晒一下简便正确的写法振奋人心了。想要实现A和B双向绑定，其实一句就可以：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RACChannelTo(<span class="keyword">self</span>, a) = RACChannelTo(<span class="keyword">self</span>, b);</span><br></pre></td></tr></table></figure><p>这就是前文提到的在内部实现好循环调用终止条件的RACChannel了。</p><h2 id="RACChannelTo的展开"><a href="#RACChannelTo的展开" class="headerlink" title="RACChannelTo的展开"></a>RACChannelTo的展开</h2><p>我们把<code>RACChannelTo(self, a)</code>先展开来，看一下它到底做了什么：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RACKVOChannel alloc] initWithTarget:<span class="keyword">self</span> keyPath:<span class="string">@"a"</span> nilValue:<span class="literal">nil</span>][<span class="string">@"followingTerminal"</span>]</span><br></pre></td></tr></table></figure><p>所以说，上面实现双向绑定的语句展开来，实际上做了两件事：</p><ol><li>为A和B分别创建了<code>channelA</code>和<code>channelB</code>。</li><li>调用<code>channelA[@&quot;followingTerminal&quot;] = channelB[@&quot;followingTerminal&quot;]</code>。</li></ol><p>如果你对宏定义展开的细节感兴趣，我觉得Sunny大大的<a href="http://blog.sunnyxx.com/2014/03/06/rac_1_macros/" target="_blank" rel="noopener">这篇博客</a>可以帮到你。</p><h2 id="RACKVOChannel如何实现双向绑定"><a href="#RACKVOChannel如何实现双向绑定" class="headerlink" title="RACKVOChannel如何实现双向绑定"></a>RACKVOChannel如何实现双向绑定</h2><p>我们看一下这段代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RACKVOChannel</span> (<span class="title">RACChannelTo</span>)</span></span><br><span class="line"></span><br><span class="line">- (RACChannelTerminal *)objectForKeyedSubscript:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(key != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    RACChannelTerminal *terminal = [<span class="keyword">self</span> valueForKey:key];</span><br><span class="line">    <span class="built_in">NSCAssert</span>([terminal isKindOfClass:RACChannelTerminal.class], <span class="string">@"Key \"%@\" does not identify a channel terminal"</span>, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> terminal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(RACChannelTerminal *)otherTerminal forKeyedSubscript:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(otherTerminal != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    RACChannelTerminal *selfTerminal = [<span class="keyword">self</span> objectForKeyedSubscript:key];</span><br><span class="line">    [otherTerminal subscribe:selfTerminal];</span><br><span class="line">    [[selfTerminal skip:<span class="number">1</span>] subscribe:otherTerminal];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><code>objectForKeyedSubscript:</code>提供了通过键<code>@“followingTerminal”</code>读取终端的能力，<code>setObject:forKeyedSubscript:</code>提供了通过键<code>@“followingTerminal”</code>设定和绑定终端的能力。</p><p>绑定的操作其实就是将两个<code>followingTerminal</code>相互订阅。注意因为两端数据是同步的，所以在正向订阅后两端的值应该一样了，所以在反向绑定的时候就可以<code>skip:1</code>来节约点性能了。</p><h2 id="RACKVOChannel在哪里打断了信号通道的循环调用"><a href="#RACKVOChannel在哪里打断了信号通道的循环调用" class="headerlink" title="RACKVOChannel在哪里打断了信号通道的循环调用"></a>RACKVOChannel在哪里打断了信号通道的循环调用</h2><p>可以看到这段代码首先创建了一个RACKVOChannel，RACKVOChannel里主要做的两件事就是<code>leadingTerminal</code>的<code>sendNext</code>和<code>leadingTerminal</code>和<code>subscribeNext</code>，这个从前面一点点读下来的读者应该都能明白，是将目标的指定属性和RACKVOChannel的<code>leadingTerminal</code>做好绑定。</p><p>我们主要关注的是，RACKVOChannel在哪里打断了信号通道的循环调用。先看<code>subscribeNext</code>段里这一部分：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set the ignoreNextUpdate flag before setting the value so this channel</span></span><br><span class="line"><span class="comment">// ignores the value in the subsequent -didChangeValueForKey: callback.</span></span><br><span class="line">[<span class="keyword">self</span> createCurrentThreadData];</span><br><span class="line"><span class="keyword">self</span>.currentThreadData.ignoreNextUpdate = <span class="literal">YES</span>;</span><br></pre></td></tr></table></figure><p>注释写得比较清楚，这个<code>ignoreNextUpdate</code>使得下一次的值修改被忽略。具体的忽略代码在<code>sendNext</code>段：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the change wasn't triggered by deallocation, only affects the last</span></span><br><span class="line"><span class="comment">// path component, and ignoreNextUpdate is set, then it was triggered by</span></span><br><span class="line"><span class="comment">// this channel and should not be forwarded.</span></span><br><span class="line"><span class="keyword">if</span> (!causedByDealloc &amp;&amp; affectedOnlyLastComponent &amp;&amp; <span class="keyword">self</span>.currentThreadData.ignoreNextUpdate) &#123;</span><br><span class="line">    [<span class="keyword">self</span> destroyCurrentThreadData];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>ignoreNextUpdate</code>为YES的时候，这里就会return出去，不会触发<code>sendNext</code>操作。</p><p>用图片标记的直观点，就是如果是在<code>leadingTerminal</code>的<code>subscribeNext</code>里修改了目标的属性值，通路会在此打断，不会重复的再把属性址改变的信号<code>sendNext</code>出去：</p><p><img src="/2017/07/27-B.png" alt="27-B"></p><h2 id="RACChannelTo总结"><a href="#RACChannelTo总结" class="headerlink" title="RACChannelTo总结"></a>RACChannelTo总结</h2><p>总之进行通常数据的双向绑定，RACChannelTo基本就是无敌的，几乎可以完成绝大部分需求了。</p><h1 id="其他常见的RACChannel相关的类扩展"><a href="#其他常见的RACChannel相关的类扩展" class="headerlink" title="其他常见的RACChannel相关的类扩展"></a>其他常见的RACChannel相关的类扩展</h1><p>RAC库对常用的组件都进行了扩展方便我们使用，下面举几个例子。</p><h2 id="NSUserDefaults-RACSupport"><a href="#NSUserDefaults-RACSupport" class="headerlink" title="NSUserDefaults (RACSupport)"></a>NSUserDefaults (RACSupport)</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (RACChannelTerminal *)rac_channelTerminalForKey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure><p>为指定的<code>key</code>创建一个双向绑定用的RACChannel，在内部和RACKVOChannel做了同样的切断循环操作。注意这里返回的是<code>followingTerminal</code>。</p><h2 id="UITextField-RACSignalSupport"><a href="#UITextField-RACSignalSupport" class="headerlink" title="UITextField (RACSignalSupport)"></a>UITextField (RACSignalSupport)</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (RACChannelTerminal&lt;<span class="built_in">NSString</span> *&gt; *)rac_newTextChannel;</span><br></pre></td></tr></table></figure><p>为文本的变更创建一个双向绑定用的RACChannel，因为本文最前面提到的原因，文本变更信号是从UI事件触发的，接受新的文本是设置到<code>text</code>属性的，所以两者相互独立本来就不会循环调用。另外注意这里返回的是<code>leadingTerminal</code>，使用上要特别注意的是初次绑定的时候不会触发一次初始化信号，这样正好可以方便配合别的<code>followingTerminal</code>使用而不需要进行<code>skip:1</code>。</p><p>其它的UI控件的RACChannel扩展和UITextField都类似。</p><h2 id="合并使用的示例"><a href="#合并使用的示例" class="headerlink" title="合并使用的示例"></a>合并使用的示例</h2><p>这里是一个和ViewModel进行绑定的例子：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果仅需要单向绑定，使用rac_textSignal</span></span><br><span class="line"><span class="comment">// RAC(self.viewModel, username) = self.usernameTextField.rac_textSignal;</span></span><br><span class="line"><span class="comment">// 如果需要双向绑定，则使用rac_newTextChannel</span></span><br><span class="line">RACChannelTo(<span class="keyword">self</span>.viewModel, username) = <span class="keyword">self</span>.usernameTextField.rac_newTextChannel;</span><br></pre></td></tr></table></figure><p>需要注意的一点是，每一次调用<code>rac_newTextChannel</code>都是创建一个新的RACChannel，如果需要进行多次重复使用，请自行把获得的RACChannelTerminal保存下来。</p><p>如果是NSUserDefaults和UITextField双向绑定，可以手动写一下订阅：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RACChannelTerminal *userDefaultsTerminal = [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] rac_channelTerminalForKey:<span class="string">@"username"</span>];</span><br><span class="line">RACChannelTerminal *textfieldTerminal = <span class="keyword">self</span>.usernameTextField.rac_newTextChannel;</span><br><span class="line">[textfieldTerminal subscribe:userDefaultsTerminal];</span><br><span class="line">[userDefaultsTerminal subscribe:textfieldTerminal];</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不得不说RAC的作者大神们伟大之极，当之无愧的ObjC新纪元开创者。RACChannel思路简单但是实现起来真的不简单，阅读代码慢慢理解RAC的精华实在是一种愉悦～</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;尝试直接用RACSignal实现双向绑定&quot;&gt;&lt;a href=&quot;#尝试直接用RACSignal实现双向绑定&quot; class=&quot;headerlink&quot; title=&quot;尝试直接用RACSignal实现双向绑定&quot;&gt;&lt;/a&gt;尝试直接用RACSignal实现双向绑定&lt;/h1&gt;&lt;p&gt;在某些场景下，我们需要把两个数据相互绑定，A的改动影响B，B的改动也影响A。&lt;/p&gt;
&lt;p&gt;为了表现上容易观察，我们先假设有一个同步两个文本框输入内容的需求。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://blog.harrisonxi.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://blog.harrisonxi.com/tags/iOS/"/>
    
      <category term="RAC" scheme="http://blog.harrisonxi.com/tags/RAC/"/>
    
      <category term="Reactive Cocoa" scheme="http://blog.harrisonxi.com/tags/Reactive-Cocoa/"/>
    
      <category term="双向绑定" scheme="http://blog.harrisonxi.com/tags/%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
    
      <category term="RACChannel" scheme="http://blog.harrisonxi.com/tags/RACChannel/"/>
    
  </entry>
  
  <entry>
    <title>iOS使用RAC实现MVVM的正经姿势</title>
    <link href="http://blog.harrisonxi.com/2017/07/iOS%E4%BD%BF%E7%94%A8RAC%E5%AE%9E%E7%8E%B0MVVM%E7%9A%84%E6%AD%A3%E7%BB%8F%E5%A7%BF%E5%8A%BF.html"/>
    <id>http://blog.harrisonxi.com/2017/07/iOS使用RAC实现MVVM的正经姿势.html</id>
    <published>2017-07-18T16:00:00.000Z</published>
    <updated>2018-06-05T03:52:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel" target="_blank" rel="noopener">MVVM</a>是微软于2005年开发出的一种软件架构设计模式，主要是为了在WPF和Silverlight中更简单的对UI实现事件驱动编程。在WPF和Silverlight中，通过MVVM成功的实现了UI布局和数据逻辑的剥离。虽然WPF和Silverlight最后都没有推广开来，但是还是让大家看到了MVVM设计模式的优秀之处。</p><p>我有幸在早年参加过<a href="https://en.wikipedia.org/wiki/Microsoft_Blend" target="_blank" rel="noopener">Expression Blend</a>的自动化测试工作，期间做了不少WPF和Silverlight的App，算是较早一批接触熟悉MVVM的天朝码农了。在iOS平台出现了可以优雅实现MVVM的RAC时，着实激动了一下。下面就让我们先从最早的MVC开始慢慢说起。</p><a id="more"></a><p>如果你想简单点直接看代码：<a href="https://github.com/HarrisonXi/MvvmDemo" target="_blank" rel="noopener">Show you the code</a>。</p><h1 id="MVC理想设计模式"><a href="#MVC理想设计模式" class="headerlink" title="MVC理想设计模式"></a>MVC理想设计模式</h1><p>MVC是一种比较古老软件架构设计模式，主旨是将代码分为UI、数据和控制逻辑三大部分：</p><p><img src="/2017/07/18-A.png" alt="18-A"></p><p>一个UI交互的整体过程：View接受用户操作发送给Controller，Controller根据操作对数据进行修改，Controller接受数据修改的通知，并根据通知更新对应的UI。当然Controller可能有一些自有逻辑会修改数据或者更新UI，从属关系上来说View和Model都属于Controller。</p><h1 id="MVC实例"><a href="#MVC实例" class="headerlink" title="MVC实例"></a>MVC实例</h1><p>这是我比较喜欢的一个实例，实现一个简单的登录界面。先罗列一下简单的需求：</p><ol><li>用户名有效长度为4-16位，无效时对应文本框显示为红色底色，有效时文本框显示为绿色底色，无输入时显示为白色底色。</li><li>密码有效长度为8-16位，对应文本框底色逻辑与用户名文本框一致。</li><li>登陆按钮在用户名和密码均有效时可用，否则禁用。</li></ol><p><img src="/2017/07/18-B.png" alt="18-B"></p><p>为了让代码看起来不那么多，我使用xib来绘制了简单的UI并完成了IBOutlet和delegate等的绑定。</p><p>然后呢需要写的代码就是大概下面这样了：</p><p><img src="/2017/07/18-C.png" alt="18-C"></p><p>这里的<code>username</code>和<code>password</code>两个属性可以看作Model层，文本框和按钮的xib就是View层，VC主体代码就是Controller层。可以看到所有的Model修改逻辑和UI更新逻辑都是在Controller里一起完成的。（<a href="https://github.com/HarrisonXi/MvvmDemo/releases/tag/MVC" target="_blank" rel="noopener">完整代码</a>）</p><h1 id="MVC解决的问题和优缺点"><a href="#MVC解决的问题和优缺点" class="headerlink" title="MVC解决的问题和优缺点"></a>MVC解决的问题和优缺点</h1><ul><li>代码成功分化为UI、数据和控制逻辑三大部分。</li><li>易于理解使用，普及成本低。</li><li>Controller拥有View和Model，几乎可以控制所有逻辑。</li><li>细节不够明确，基本上不明确归属的代码全部会放在Controller层。</li><li>和UI操作事件绑定较重，难以进行单元测试。</li></ul><h1 id="MVC实际使用状况"><a href="#MVC实际使用状况" class="headerlink" title="MVC实际使用状况"></a>MVC实际使用状况</h1><p>因为上一节中提到的3和4两点，很多代码都只能写在Controller层。还因为xib的特殊性，对多人协作十分不友好，导致大部分UI的布局和初始化代码要用代码实现，而这些代码写成单独的类也多有不便，导致本该出现在View层的代码也堆积在了Controller层。而且在iOS中，UIViewController和UIView本来就是一一对应的。这就导致了MVC从最早的<strong>Model-View-Controller</strong>最终一点点变成了<strong>Massive-View-Controller</strong>：</p><p><img src="/2017/07/18-D.png" alt="18-D"></p><h1 id="MVP设计模式"><a href="#MVP设计模式" class="headerlink" title="MVP设计模式"></a>MVP设计模式</h1><p>所谓设计模式，就是软件设计过程中为了解决普遍性问题而提出的通用解决方案。MVP的出现就是为了解决MVC的Controller越来越臃肿的问题，进一步明确代码的分工：</p><p><img src="/2017/07/18-E.png" alt="18-E"></p><p>这个图看上去和MVC很相似，但是这里的实虚线和MVC设计模式不同。所表示的意义为View层持有Presenter层，Presenter层持有Model层，View层并不可直接访问到Model层。整体的UI交互流程和MVC类似。</p><p>这么做的意义就在于真正意义上的将UI逻辑和数据逻辑隔离，而隔离之后就可以更方便的对数据逻辑部分进行单元测试，隔离的另一个好处就是解开了一部分的耦合。</p><h1 id="MVP实例"><a href="#MVP实例" class="headerlink" title="MVP实例"></a>MVP实例</h1><p>接着刚刚的实例，我们在它的基础上继续进行修改。</p><p>首先我们需要定义一个Presenter，头文件内把所有可接受的用户操作和更新UI需要用的回调定义好：</p><p><img src="/2017/07/18-F.png" alt="18-F"></p><p>Presenter的内部实现：</p><p><img src="/2017/07/18-G.png" alt="18-G"></p><p>可以看到Presenter做的事情就是把原来Controller的逻辑控制相关代码抽离出来构建成一个单独的类。接下来看一看对应的Controller现在变成什么样：</p><p><img src="/2017/07/18-H.png" alt="18-H"></p><p>现在Controller的代码变得更加清晰了：两个更新数据的调用，三个更新UI的调用，多了一些初始化Presenter的操作。</p><p>因为现在Presenter只包含逻辑，所以我们也较容易实现一个单元测试：</p><p><img src="/2017/07/18-I.png" alt="18-I"></p><p>从结果可以看到Controller的代码转移了一部分到Presenter，MVP也成功把逻辑和UI代码分离了。（<a href="https://github.com/HarrisonXi/MvvmDemo/releases/tag/MVP" target="_blank" rel="noopener">完整代码</a>）</p><h1 id="MVP优缺点"><a href="#MVP优缺点" class="headerlink" title="MVP优缺点"></a>MVP优缺点</h1><ul><li>UI布局和数据逻辑代码划分界限更明确。</li><li>理解难度尚可，较容易推广。</li><li>解决了Controller的臃肿问题。</li><li>Presenter-Model层可以进行单元测试。</li><li>需要额外写大量接口定义和逻辑代码（或者自己实现KVO监视）。</li></ul><h1 id="MVVM设计模式"><a href="#MVVM设计模式" class="headerlink" title="MVVM设计模式"></a>MVVM设计模式</h1><p>随着UI交互越来越复杂，MVP本身的一些缺点还是会暴露出来。</p><p>比如虽然是可以写单元测试，但是单元测试写起来还是有很多“啰嗦”的部分，需要模拟一些假的UI处理逻辑来进行结果的验证，即使用block写法这个部分的代码量也省不了太多。</p><p>所有的用户操作和更新UI的回调需要细细定义，随着交互越来越复杂，这些定义都要有很大一坨代码。</p><p>逻辑过于复杂的情况下，Present本身也会变得臃肿难以重用，代码也会变的更加难以阅读和维护。</p><p>这时候，MVVM出现了，为了解决以上大部分问题：</p><p><img src="/2017/07/18-J.png" alt="18-J"></p><p>首先ViewModel-Model层和之前的Present-Model层一样，没有什么大的变化。View持有ViewModel，这个和MVP也一样。变化主要在两个方面：</p><ol><li>ViewModel相较于Present，不仅仅是个逻辑处理机，它附带了自己的状态，所以被才可以被称为“Model”。ViewModel也因为这个变的更加独立完整，<strong>我们更容易通过ViewModel的状态去进行单元测试</strong>。Presenter在没有设置回调的时候其实一直在做空运算而已，运算得到的值没有进行存储，下次必须重新运算。</li><li>View不直接通过传递用户操作来控制ViewModel，ViewModel也不直接通过回调来修改View。对常用的数据和UI控件的事件&amp;属性，MVVM框架的底层均进行了封装，使得我们可以进行数据绑定操作。简单来说我们可以用类似<code>[viewModel.username bind:usernameTextField.text]</code>类似的操作使得viewModel的属性和UI控件的属性相互绑定，其中一方修改的时候另一方直接自动做对应更改。<strong>这样的话我们就不用重复的书写很多回调操作，也不用处理一大堆UI控件的delegate事件</strong>。</li></ol><p>其实MVVM的精华小部分在ViewModel，更大部分就在数据绑定，甚至有很多人觉得应该称MVVM为MVB（Model-View-Binder）。</p><p>数据绑定引申出来的一个概念就是数据管道（转换器），这个和大家学的数字电路比较相似：</p><p><img src="/2017/07/18-K.png" alt="18-K"></p><p>这里我们有ABC三个数据源和两个双输入的转换器，我们可以进行组合得出各种想要的结果（如上图），甚至于我们可以多次组合来完成更复杂的计算（如下图）：</p><p><img src="/2017/07/18-L.png" alt="18-L"></p><p>这里的转换器就带来了第三点改进：</p><ol><li>基于数据绑定和数据管道，<strong>可以对运算逻辑进行拆分和重用，最大程度的使代码易读易维护</strong>。</li></ol><h1 id="MVVM实例"><a href="#MVVM实例" class="headerlink" title="MVVM实例"></a>MVVM实例</h1><p>还是接着刚刚的工程，首先要参照<a href="https://github.com/ReactiveCocoa/ReactiveObjC" target="_blank" rel="noopener">Reactive Cocoa</a>的文档把RAC添加到工程里。</p><h2 id="ViewModel的定义"><a href="#ViewModel的定义" class="headerlink" title="ViewModel的定义"></a>ViewModel的定义</h2><p>然后我们首先要把Present改造成ViewModel：</p><p><img src="/2017/07/19-A.png" alt="19-A"></p><p>这里可以看到作为ViewModel输出值的属性设置成了readonly，剩下的<code>username</code>和<code>password</code>是输入值。</p><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>值得一提的是软件工程中最好是测试驱动开发（TDD）而不是写完逻辑再补测试，所以我们先改好单元测试：</p><p><img src="/2017/07/19-B.png" alt="19-B"></p><p>从单元测试也很容易看出来ViewModel现在足够独立并易于测试。</p><h2 id="View层和ViewModel层的绑定"><a href="#View层和ViewModel层的绑定" class="headerlink" title="View层和ViewModel层的绑定"></a>View层和ViewModel层的绑定</h2><p>我们再看一眼现在Controller应该怎么写：</p><p><img src="/2017/07/19-C.png" alt="19-C"></p><p>首先看到原来的一行<code>loginButton</code>初始化代码没有了，因为数据绑定是自动更新的，初次绑定就会初始化状态。</p><p>对ViewModel进行输入数据的绑定，不再需要写UITextFieldDelegate然后再传递事件，一行代码完成绑定。</p><p>同样将ViewModel的输出数据绑定到UI，不需要再实现对应的回调，一样一行代码完成绑定。</p><p>这就是MVVM设计模式在最理想的情况下，Controller里需要和ViewModel交互的所有代码内容。</p><h2 id="数据管道（转换器）"><a href="#数据管道（转换器）" class="headerlink" title="数据管道（转换器）"></a>数据管道（转换器）</h2><p>现在来说说刚刚的<code>ConvertInputStateToColor</code>，它其实就是一个状态到颜色的转换器：</p><p><img src="/2017/07/19-D.png" alt="19-D"></p><p><img src="/2017/07/19-E.png" alt="19-E"></p><p>这里利用RACSignal的map方法做了一个映射，这就是我们的转换器。当然我们以后也可以实现别的转换器来进行方便的替换，比如实现一个仅在有效态显示绿色其他状态都显示白色的转换器。另外这个转换器如果写的更通用点，也可以被别的模块重复使用。</p><h2 id="ViewModel的UI无关性／转换器组合的多样可能性"><a href="#ViewModel的UI无关性／转换器组合的多样可能性" class="headerlink" title="ViewModel的UI无关性／转换器组合的多样可能性"></a>ViewModel的UI无关性／转换器组合的多样可能性</h2><p>这里要提一下为什么ViewModel不直接提供颜色值的输出：</p><ol><li>ViewModel应该不关心具体的UI相关逻辑，只关心自己的逻辑正确和独立完整性。</li><li>易于进行单元测试，枚举当然比颜色值好检查点……</li><li>提供更为基础的状态，这样和不同的转换器组合会产生更多的可能性。</li></ol><p>这里的可能性指什么呢？举个例子：出现了用户有输入内容时展示对应文本框清空按钮的新需求。这时候我们只需要完成一个新的转换器：<code>InputStateEmpty</code>时返回<code>isHidden = YES</code>；其余情况下返回<code>isHidden = NO</code>。然后把对应输出源通过转换器绑定到清空按钮的<code>isHidden</code>属性上即可。另外上一节提到的另一种颜色转换器，也是一种多样性的体现。</p><ol><li>可以进行二次组合，用以计算输出值<code>loginEnabled</code>。（见下一节）</li></ol><h2 id="ViewModel的完整实现"><a href="#ViewModel的完整实现" class="headerlink" title="ViewModel的完整实现"></a>ViewModel的完整实现</h2><p><img src="/2017/07/19-F.png" alt="19-F"></p><p>需要把输出源对应的属性偷偷改成readwrite的先，不然不可写的话绑定的时候会跪。😂</p><p>可以看到ViewModel现在就三块逻辑：</p><ol><li>内部实现了一个转换器，监视<code>username</code>值更新对应的<code>usernameInputState</code>值。</li><li>内部又实现了一个转换器，监视<code>password</code>值更新对应的<code>passwordInputState</code>值。</li><li>监视<code>usernameInputState</code>和<code>passwordInputState</code>两个输出值，经过转换再输出<code>loginEnabled</code>值。</li></ol><p>这三块逻辑都十分独立且逻辑清晰，这就是MVVM或者说RAC带来的优势。</p><p>回想一下最早时候MVC里的Controller，在UITextField的回调里UI操作和数据逻辑混杂在一起，计算<code>loginEnabled</code>属性的逻辑还夹杂在计算文本框颜色的逻辑中。</p><h2 id="相似的代码可以再次合并"><a href="#相似的代码可以再次合并" class="headerlink" title="相似的代码可以再次合并"></a>相似的代码可以再次合并</h2><p>刚刚的代码里，其实计算<code>usernameInputState</code>和<code>passwordInputState</code>两个值的转换器十分类似。如果以后还可能有类似的转换需求，我们应该把它俩的转换器再合并成独立的转换器，方便重用：</p><p><img src="/2017/07/19-G.png" alt="19-G"></p><p><img src="/2017/07/19-H.png" alt="19-H"></p><p>记得做好断言防止写错调用代码，不过看上去转换器逻辑不需要额外做错误保护。</p><p>有了新的转换器，如果以后出现了验证码限制长度为5之类的需求，它就有用武之地了。</p><p>在此基础下ViewModel的代码也再次简化为：</p><p><img src="/2017/07/19-I.png" alt="19-I"></p><p>可以看到代码更清晰易懂了😎，虽然貌似代码量没有减少多少🙄️。</p><p>另外这里也看出来很灵活的一点，转换器可以直接写ViewModel里，也可以抽离成单独的类，这需要根据具体情况来定不同的写法。</p><h2 id="为转换器写单元测试"><a href="#为转换器写单元测试" class="headerlink" title="为转换器写单元测试"></a>为转换器写单元测试</h2><p>简单点的办法是把逻辑从RACSignal的map方法里抽出来，这样就可以单独测试逻辑了：</p><p><img src="/2017/07/19-J.png" alt="19-J"></p><p>添加完单元测试的完整MVVM设计模式实例代码在这里：<a href="https://github.com/HarrisonXi/MvvmDemo/releases/tag/MVVM" target="_blank" rel="noopener">完整代码</a>。</p><p>当然，如果不想破坏转换器类的实现方式，有另一种单元测试的方案（这个我会另写一篇博客来介绍）：</p><p><img src="/2017/07/19-K.png" alt="19-K"></p><h1 id="MVVM优缺点"><a href="#MVVM优缺点" class="headerlink" title="MVVM优缺点"></a>MVVM优缺点</h1><ol><li>UI布局和数据逻辑代码划分界限更明确，数据逻辑还可以细分成各种转换器。</li><li>很难理解正确使用姿势，使用难度高容易出错，且出错调试难度也很大。</li><li>代码量相较MVP应该有所减少，逻辑更清晰使得代码易读性重用性有所提高（用对姿势的话）。</li><li>更方便实现单元测试。</li><li>内存和CPU开销较大。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>设计模式不是银弹，任何设计模式均有适用的场景，并没有某种设计模式可以解决所有的问题。</p><p>比如UI交互较少较轻的页面，用MVC直接实现就会很轻松。</p><p>比如团队整体水平较低，强行使用MVVM也会面临困境。</p><p>学习和了解新的设计模式主要是开拓自己的眼界，以后面临问题的时候可以多一个新的选择。</p><p>而且谁说MVC就不能用RAC做数据绑定呢？MVC的Controller太臃肿了，也可以用Category来分散代码不是么？</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MVVM&lt;/a&gt;是微软于2005年开发出的一种软件架构设计模式，主要是为了在WPF和Silverlight中更简单的对UI实现事件驱动编程。在WPF和Silverlight中，通过MVVM成功的实现了UI布局和数据逻辑的剥离。虽然WPF和Silverlight最后都没有推广开来，但是还是让大家看到了MVVM设计模式的优秀之处。&lt;/p&gt;
&lt;p&gt;我有幸在早年参加过&lt;a href=&quot;https://en.wikipedia.org/wiki/Microsoft_Blend&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Expression Blend&lt;/a&gt;的自动化测试工作，期间做了不少WPF和Silverlight的App，算是较早一批接触熟悉MVVM的天朝码农了。在iOS平台出现了可以优雅实现MVVM的RAC时，着实激动了一下。下面就让我们先从最早的MVC开始慢慢说起。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://blog.harrisonxi.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://blog.harrisonxi.com/tags/iOS/"/>
    
      <category term="MVC" scheme="http://blog.harrisonxi.com/tags/MVC/"/>
    
      <category term="MVVM" scheme="http://blog.harrisonxi.com/tags/MVVM/"/>
    
      <category term="设计模式" scheme="http://blog.harrisonxi.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="RAC" scheme="http://blog.harrisonxi.com/tags/RAC/"/>
    
      <category term="Reactive Cocoa" scheme="http://blog.harrisonxi.com/tags/Reactive-Cocoa/"/>
    
      <category term="单元测试" scheme="http://blog.harrisonxi.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>贪婪的海盗</title>
    <link href="http://blog.harrisonxi.com/2017/07/%E8%B4%AA%E5%A9%AA%E7%9A%84%E6%B5%B7%E7%9B%97.html"/>
    <id>http://blog.harrisonxi.com/2017/07/贪婪的海盗.html</id>
    <published>2017-07-11T16:00:00.000Z</published>
    <updated>2018-06-05T03:52:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>5名海盗在宝藏中发现了100颗钻石，他们决定采取投票的办法来分掉这些钻石。</p><p>他们首先抽签决定了自己提出方案的顺序，这里5人按抽签顺序称为ABCDE。</p><p>A首先提出一种分配钻石的方案，超过半数的人同意时，将按照这种方法分配钻石；否则，A将被丢进海里喂鲨鱼。（这里A参加投票，即需要3个人同意）</p><a id="more"></a><p>如果A被喂鲨鱼了，再由B提出一种分配钻石的方案，超过半数的人同意时，将按照这种方法分配钻石；否则，B也将被丢进海里喂鲨鱼。（这里B参加投票，即需要3个人同意）</p><p>以此类推，直到有方案通过，或者仅剩E一人。最终钻石会被如何分配？</p><p>额外条件补充：</p><ol><li>所有的钻石等价</li><li>海盗们都智力过人，实力相当，冷静过人</li><li>海盗们都很贪婪，在保命的条件下会想要尽可能多的钻石</li><li>海盗们关系不是很好，两种分配方案下能获得的钻石一样多也会给前一个提议者投反对票</li></ol><p>木有什么好提示的。🙄️</p><p>如果你想知道答案：<a href="#推理过程和答案">点这里</a></p><p>　</p><p>　</p><p>　</p><p>　</p><p>　</p><p>　</p><p>　</p><p>　</p><p>　</p><p>　</p><p>　</p><p>　</p><p>　</p><p>　</p><p>　</p><p>　</p><h1 id="推理过程和答案"><a href="#推理过程和答案" class="headerlink" title="推理过程和答案"></a>推理过程和答案</h1><p>从只剩DE俩人的情况开始说，因为只剩E一人的时候他可以独吞所有钻石，所以他不会给D投同意票的。只剩俩人的时候D必定会死，对应分赃方案：[0, 0, 0, 0, 100]</p><p>如果剩CDE仨人时，C推理了以上的结果，D不想死肯定会投同意票。剩仨人的时候C可以独吞所有钻石，对应分赃方案：[0, 0, 100, 0, 0]</p><p>剩BCDE四人时，B推理了以上的结果，C在自己死后可以独吞钻石肯定不会投同意票，需要拉拢DE俩人的同意票才能不被喂鲨鱼。B自己尽可能多拿钻石的条件下，对应分赃方案：[0, 98, 0, 1, 1]</p><p>A推理了以上的结果，需要拉拢两个人，而拉拢B的代价太大，最终定下来需要拉拢C，并再拉拢DE中的一人。对应分赃方案：[97, 0, 1, 2, 0]或者[97, 0, 1, 0, 2]</p><h1 id="然而不一定就这么一个答案"><a href="#然而不一定就这么一个答案" class="headerlink" title="然而不一定就这么一个答案"></a>然而不一定就这么一个答案</h1><p>剩仨人的时候，大家都遵守规则，同意票不过半则还有两个“执法者”对一个对象“执法”。但是只剩俩人的时候，作为海盗，为什么要乖乖“伏法”喂鲨鱼呢？在这种假设下DE实力也相当，双方取胜概率相同，另外考虑可能有同归于尽的情况，双方胜率其实都不到50%。所以这种情况下双方理智下来，应该谈判平分钻石：[0, 0, 0, 50, 50]</p><p>剩CDE仨人，C需要拉拢其中一位。假设拉拢的是D，则对应分赃方案：[0, 0, 49, 51, 0]</p><p>剩BCDE四人，B需要拉拢两位。因为轮到C来提出方案的时候，C可能拉拢D也可能拉拢E，所以DE其实从平均期望来说可以拿到25.5颗钻石。B拉拢这两位比较廉价一点，对应分配方案：[0, 48, 0, 26, 26]</p><p>A推理了以上的结果，需要拉拢两个人，那就要拉拢C，再拉拢DE中的一人。假设拉拢的是C和D俩人，则对应分赃方案：[72, 0, 1, 27, 0]</p><p>海盗还懂概率和统计，不怕海盗凶就怕海盗有文化啊233。😂</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;5名海盗在宝藏中发现了100颗钻石，他们决定采取投票的办法来分掉这些钻石。&lt;/p&gt;
&lt;p&gt;他们首先抽签决定了自己提出方案的顺序，这里5人按抽签顺序称为ABCDE。&lt;/p&gt;
&lt;p&gt;A首先提出一种分配钻石的方案，超过半数的人同意时，将按照这种方法分配钻石；否则，A将被丢进海里喂鲨鱼。（这里A参加投票，即需要3个人同意）&lt;/p&gt;
    
    </summary>
    
      <category term="逻辑" scheme="http://blog.harrisonxi.com/categories/%E9%80%BB%E8%BE%91/"/>
    
    
      <category term="逻辑" scheme="http://blog.harrisonxi.com/tags/%E9%80%BB%E8%BE%91/"/>
    
      <category term="海盗" scheme="http://blog.harrisonxi.com/tags/%E6%B5%B7%E7%9B%97/"/>
    
      <category term="推理" scheme="http://blog.harrisonxi.com/tags/%E6%8E%A8%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>鬼谷子问徒</title>
    <link href="http://blog.harrisonxi.com/2017/07/%E9%AC%BC%E8%B0%B7%E5%AD%90%E9%97%AE%E5%BE%92.html"/>
    <id>http://blog.harrisonxi.com/2017/07/鬼谷子问徒.html</id>
    <published>2017-07-05T16:00:00.000Z</published>
    <updated>2018-06-05T03:52:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目的真实性已经不重要了，不要在意这个细节。🙄️</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>孙膑、庞涓都是鬼谷子的徒弟。（反正意思就是他们仨都智慧过人）</p><p>一天鬼谷子从2到99中选出了两个不同的整数，把积告诉孙，把和告诉庞。</p><a id="more"></a><p>庞说：我虽然不能确定这两个数是什么，但是我肯定你也不知道这两个数是什么。</p><p>孙说：我本来的确不知道，但是听你这么一说，我现在能够确定这两个数字了。</p><p>庞说：既然你这么说，我现在也知道这两个数字是什么了。</p><p>请问这两个数字是什么？为什么？（题目大意就是答得出来你也智慧过人）</p><h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h1><p>高亮选择下一行查看提示。</p><p><em>建议码代码来辅助解题，就酱……另外，考虑一些质数相关的排除法。</em></p><h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p><a href="#真答案">点我前往</a></p><p>　</p><p>　</p><p>　</p><p>　</p><p>　</p><p>　</p><p>　</p><p>　</p><p>　</p><p>　</p><p>　</p><p>　</p><p>　</p><p>　</p><p>　</p><p>　</p><h1 id="真答案"><a href="#真答案" class="headerlink" title="真答案"></a>真答案</h1><p>恭喜你发现了新大陆！🎉</p><h2 id="庞涓：我不能确定这两个数是什么"><a href="#庞涓：我不能确定这两个数是什么" class="headerlink" title="庞涓：我不能确定这两个数是什么"></a>庞涓：我不能确定这两个数是什么</h2><p>庞涓拿到的和不可能是5或者6（5=2+3，6=2+4，均有唯一解），同理也不可能是196或者197。</p><p>所以两数字和的范围一定是7~195。</p><h2 id="庞涓：我肯定你也不知道这两个数是什么"><a href="#庞涓：我肯定你也不知道这两个数是什么" class="headerlink" title="庞涓：我肯定你也不知道这两个数是什么"></a>庞涓：我肯定你也不知道这两个数是什么</h2><p>知道两个质数的积一定可以推算出唯一解，所以庞涓知道的数一定无法拆解成两个质数的和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">41</span>,<span class="number">43</span>,<span class="number">47</span>,<span class="number">53</span>,<span class="number">59</span>,<span class="number">61</span>,<span class="number">67</span>,<span class="number">71</span>,<span class="number">73</span>,<span class="number">79</span>,<span class="number">83</span>,<span class="number">89</span>,<span class="number">97</span>] <span class="comment"># 质数集合</span></span><br><span class="line">b = range(<span class="number">7</span>,<span class="number">196</span>) <span class="comment"># 庞涓可能拿到的和集合</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(a)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(a)):</span><br><span class="line">        result = a[i] + a[j] <span class="comment"># 两个质数的和</span></span><br><span class="line">        <span class="keyword">if</span> result <span class="keyword">in</span> b:</span><br><span class="line">            b.remove(result) <span class="comment"># 庞涓不可能拿到两个质数的和，从结果中移除</span></span><br><span class="line"><span class="keyword">print</span> b</span><br></pre></td></tr></table></figure><p>用上面一段python，得到庞涓手上的和一定是在以下范围内：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">11</span>,<span class="number">17</span>,<span class="number">23</span>,<span class="number">27</span>,<span class="number">29</span>,<span class="number">35</span>,<span class="number">37</span>,<span class="number">41</span>,<span class="number">47</span>,<span class="number">51</span>,<span class="number">53</span>,<span class="number">57</span>,<span class="number">59</span>,<span class="number">65</span>,<span class="number">67</span>,<span class="number">71</span>,<span class="number">77</span>,<span class="number">79</span>,<span class="number">83</span>,<span class="number">87</span>,<span class="number">89</span>,<span class="number">93</span>,<span class="number">95</span>,<span class="number">97</span>,<span class="number">101</span>,<span class="number">103</span>,<span class="number">105</span>,<span class="number">107</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">113</span>,<span class="number">115</span>,<span class="number">117</span>,<span class="number">119</span>,<span class="number">121</span>,<span class="number">123</span>,<span class="number">125</span>,<span class="number">127</span>,<span class="number">129</span>,<span class="number">131</span>,<span class="number">133</span>,<span class="number">135</span>,<span class="number">137</span>,<span class="number">139</span>,<span class="number">141</span>,<span class="number">143</span>,<span class="number">145</span>,<span class="number">147</span>,<span class="number">149</span>,<span class="number">151</span>,<span class="number">153</span>,<span class="number">155</span>,<span class="number">157</span>,<span class="number">159</span>,<span class="number">161</span>,<span class="number">163</span>,<span class="number">165</span>,<span class="number">166</span>,<span class="number">167</span>,<span class="number">169</span>,<span class="number">171</span>,<span class="number">173</span>,<span class="number">174</span>,<span class="number">175</span>,<span class="number">177</span>,<span class="number">178</span>,<span class="number">179</span>,<span class="number">181</span>,<span class="number">182</span>,<span class="number">183</span>,<span class="number">184</span>,<span class="number">185</span>,<span class="number">187</span>,<span class="number">188</span>,<span class="number">189</span>,<span class="number">190</span>,<span class="number">191</span>,<span class="number">192</span>,<span class="number">193</span>,<span class="number">194</span>,<span class="number">195</span>]</span><br></pre></td></tr></table></figure><p>因为题目限制了数字的范围，所以其实如果庞涓手上的和过大，孙膑也有机会得到唯一解。所谓过大，就是孙膑有机会拿到大于上限一半的某个质因数。大于99/2的第一个质数就是53了，那么从55开始庞涓得到的和就可拆分成55=53+2、56=53+3、57=53+4……乘积的因数有53则孙膑能得到唯一解，而庞涓确认孙膑得不到唯一解，所以庞涓手上的和范围缩减为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">11</span>,<span class="number">17</span>,<span class="number">23</span>,<span class="number">27</span>,<span class="number">29</span>,<span class="number">35</span>,<span class="number">37</span>,<span class="number">41</span>,<span class="number">47</span>,<span class="number">51</span>,<span class="number">53</span>]</span><br></pre></td></tr></table></figure><h2 id="孙膑：听你这么一说，我现在能够确定这两个数字了"><a href="#孙膑：听你这么一说，我现在能够确定这两个数字了" class="headerlink" title="孙膑：听你这么一说，我现在能够确定这两个数字了"></a>孙膑：听你这么一说，我现在能够确定这两个数字了</h2><p>孙膑也推算出了两数和的范围，剩下的就是分解质因数，看看组合起来的两数和在不在上面范围内。</p><p>比如积是18，那么可能是2x9或者3x6，但是2+9=11在上面和范围内，3+6=9不在上面和的范围内，所以孙膑可以获得唯一解：两个数是2和9。</p><p>比如积是30，那么可能是2x15或者3x10或者5x6，但是2+15=17且5+6=11都在上面和的范围内，所这种情况孙膑是拿不到唯一解的。</p><p>所以我们要做的事情就是穷举每一个有效和所拆分出的两个数，对应的乘积有没有重复。</p><p>比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">11=2+9 --&gt; 2x9=18</span><br><span class="line">11=3+8 --&gt; 3x8=24</span><br><span class="line">11=4+7 --&gt; 4x7=28</span><br><span class="line">11=5+6 --&gt; 5x6=30</span><br><span class="line">17=2+15 --&gt; 2x15=30</span><br><span class="line">17=3+14 --&gt; 3x14=42</span><br><span class="line">17=4+13 --&gt; 4x13=52</span><br><span class="line">17=5+12 --&gt; 5x12=60</span><br><span class="line">17=6+11 --&gt; 6x11=66</span><br><span class="line">17=7+10 --&gt; 7x10=70</span><br><span class="line">17=8+9 --&gt; 8x9=72</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>这里30出现了两次，所以30就不可能是孙膑拿到的积之一。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">b = [<span class="number">11</span>,<span class="number">17</span>,<span class="number">23</span>,<span class="number">27</span>,<span class="number">29</span>,<span class="number">35</span>,<span class="number">37</span>,<span class="number">41</span>,<span class="number">47</span>,<span class="number">51</span>,<span class="number">53</span>]</span><br><span class="line">c = []</span><br><span class="line">d = [] <span class="comment"># 用来记录重复出现过的乘积</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> b:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>, int(i * <span class="number">0.5</span>) + <span class="number">1</span>):</span><br><span class="line">        result = j * (i - j) <span class="comment"># 孙膑可能拿到的积</span></span><br><span class="line">        <span class="keyword">if</span> result <span class="keyword">in</span> c:</span><br><span class="line">            <span class="keyword">if</span> result <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                d.append(result) <span class="comment"># 重复出现过的积</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c.append(result) <span class="comment"># 首次出现积</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> d:</span><br><span class="line">    c.remove(i)  <span class="comment"># 重复出现过的积得不到唯一解，移除</span></span><br><span class="line"><span class="keyword">print</span> c</span><br></pre></td></tr></table></figure><p>用上面一段python，得到孙膑手上的积一定是在以下范围内：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">18</span>,<span class="number">24</span>,<span class="number">28</span>,<span class="number">52</span>,<span class="number">76</span>,<span class="number">112</span>,<span class="number">130</span>,<span class="number">50</span>,<span class="number">92</span>,<span class="number">110</span>,<span class="number">140</span>,<span class="number">152</span>,<span class="number">162</span>,<span class="number">170</span>,<span class="number">176</span>,<span class="number">182</span>,<span class="number">54</span>,<span class="number">100</span>,<span class="number">138</span>,<span class="number">154</span>,<span class="number">168</span>,<span class="number">190</span>,<span class="number">198</span>,<span class="number">204</span>,<span class="number">208</span>,<span class="number">96</span>,<span class="number">124</span>,<span class="number">174</span>,<span class="number">216</span>,<span class="number">234</span>,<span class="number">250</span>,<span class="number">276</span>,<span class="number">294</span>,<span class="number">304</span>,<span class="number">306</span>,<span class="number">160</span>,<span class="number">186</span>,<span class="number">232</span>,<span class="number">252</span>,<span class="number">336</span>,<span class="number">340</span>,<span class="number">114</span>,<span class="number">148</span>,<span class="number">238</span>,<span class="number">288</span>,<span class="number">310</span>,<span class="number">348</span>,<span class="number">364</span>,<span class="number">390</span>,<span class="number">400</span>,<span class="number">408</span>,<span class="number">414</span>,<span class="number">418</span>,<span class="number">172</span>,<span class="number">246</span>,<span class="number">280</span>,<span class="number">370</span>,<span class="number">442</span>,<span class="number">480</span>,<span class="number">496</span>,<span class="number">510</span>,<span class="number">522</span>,<span class="number">532</span>,<span class="number">550</span>,<span class="number">552</span>,<span class="number">98</span>,<span class="number">144</span>,<span class="number">188</span>,<span class="number">230</span>,<span class="number">308</span>,<span class="number">344</span>,<span class="number">410</span>,<span class="number">440</span>,<span class="number">468</span>,<span class="number">494</span>,<span class="number">518</span>,<span class="number">560</span>,<span class="number">578</span>,<span class="number">594</span>,<span class="number">608</span>,<span class="number">620</span>,<span class="number">638</span>,<span class="number">644</span>,<span class="number">648</span>,<span class="number">650</span>,<span class="number">240</span>,<span class="number">282</span>,<span class="number">360</span>,<span class="number">430</span>,<span class="number">492</span>,<span class="number">520</span>,<span class="number">570</span>,<span class="number">592</span>,<span class="number">612</span>,<span class="number">646</span>,<span class="number">660</span>,<span class="number">672</span>,<span class="number">682</span>,<span class="number">690</span>,<span class="number">696</span>,<span class="number">700</span>,<span class="number">702</span>]</span><br></pre></td></tr></table></figure><h2 id="庞涓：我现在也知道这两个数字是什么了"><a href="#庞涓：我现在也知道这两个数字是什么了" class="headerlink" title="庞涓：我现在也知道这两个数字是什么了"></a>庞涓：我现在也知道这两个数字是什么了</h2><p>庞涓现在也知道了所有积的范围，他要做的就是把自己的和拆开来，看看相乘的积在不在上面范围里。</p><p>假设庞涓的和是11，那么积可能为2x9=18或者3x8=24、4x7=28，都在上面的范围内，所以得不到唯一解。</p><p>所以和上面的类似，我们又要做一次穷举。这次我们有两种解法，一种是从和下手，一种是从积下手。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 紧接着上一节代码的后面运行</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> b:</span><br><span class="line">    count = <span class="number">0</span> <span class="comment"># 记录和拆成的两个数相乘能对应几个有效积</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>, int(i * <span class="number">0.5</span>) + <span class="number">1</span>):</span><br><span class="line">        result = j * (i - j) <span class="comment"># 得到的积</span></span><br><span class="line">        <span class="keyword">if</span> result <span class="keyword">in</span> c:</span><br><span class="line">            count = count + <span class="number">1</span> <span class="comment"># 对应的有效积多了一个</span></span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">print</span> i <span class="comment"># 仅能出现一次有效积的和为答案</span></span><br></pre></td></tr></table></figure><p>从和下手，仅对应一个有效积时，可获得唯一解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure><p>从积下手要分解质因数，写起来比较复杂就不写了先。🙄️</p><p>所以最终的结果就是庞涓的和是17，孙膑的积是52，这两个数是4、13。</p><h2 id="验算"><a href="#验算" class="headerlink" title="验算"></a>验算</h2><p>4 x 13 = 52， 4 + 13 = 17（大意：我智慧过人，快夸夸我）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目的真实性已经不重要了，不要在意这个细节。🙄️&lt;/p&gt;
&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;孙膑、庞涓都是鬼谷子的徒弟。（反正意思就是他们仨都智慧过人）&lt;/p&gt;
&lt;p&gt;一天鬼谷子从2到99中选出了两个不同的整数，把积告诉孙，把和告诉庞。&lt;/p&gt;
    
    </summary>
    
      <category term="逻辑" scheme="http://blog.harrisonxi.com/categories/%E9%80%BB%E8%BE%91/"/>
    
    
      <category term="逻辑" scheme="http://blog.harrisonxi.com/tags/%E9%80%BB%E8%BE%91/"/>
    
      <category term="数学" scheme="http://blog.harrisonxi.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>A为大于3的质数，证明A的平方减1为24的倍数</title>
    <link href="http://blog.harrisonxi.com/2017/07/A%E4%B8%BA%E5%A4%A7%E4%BA%8E3%E7%9A%84%E8%B4%A8%E6%95%B0%EF%BC%8C%E8%AF%81%E6%98%8EA%E7%9A%84%E5%B9%B3%E6%96%B9%E5%87%8F1%E4%B8%BA24%E7%9A%84%E5%80%8D%E6%95%B0.html"/>
    <id>http://blog.harrisonxi.com/2017/07/A为大于3的质数，证明A的平方减1为24的倍数.html</id>
    <published>2017-07-03T16:00:00.000Z</published>
    <updated>2018-06-05T03:52:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目是让你们做的，写出来你们就不小心看到答案了，或者忍不住偷偷瞄答案？</p><p>如果实在需要的话，选择下一行看高亮提示：</p><a id="more"></a><p><em>毕竟不是考数学……透露一下：A x A - 1 = (A + 1) x (A - 1)</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目是让你们做的，写出来你们就不小心看到答案了，或者忍不住偷偷瞄答案？&lt;/p&gt;
&lt;p&gt;如果实在需要的话，选择下一行看高亮提示：&lt;/p&gt;
    
    </summary>
    
      <category term="逻辑" scheme="http://blog.harrisonxi.com/categories/%E9%80%BB%E8%BE%91/"/>
    
    
      <category term="逻辑" scheme="http://blog.harrisonxi.com/tags/%E9%80%BB%E8%BE%91/"/>
    
      <category term="数学" scheme="http://blog.harrisonxi.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>ObjC中的define、static、extern和const</title>
    <link href="http://blog.harrisonxi.com/2017/06/ObjC%E4%B8%AD%E7%9A%84define%E3%80%81static%E3%80%81extern%E5%92%8Cconst.html"/>
    <id>http://blog.harrisonxi.com/2017/06/ObjC中的define、static、extern和const.html</id>
    <published>2017-06-04T16:00:00.000Z</published>
    <updated>2018-12-21T08:28:22.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>讲道理这些用处都完全不一样，为什么大家喜欢一起讲……那么既然都喜欢一起讲，我也写在一起好了……</p><p>另外值得一提的是，这些其实就是纯C的东西，并不是ObjC才特有的。</p><a id="more"></a><h1 id="Static"><a href="#Static" class="headerlink" title="Static"></a>Static</h1><p>参照<a href="https://en.wikipedia.org/wiki/Static_(keyword" target="_blank" rel="noopener">维基百科</a>)，C语言里对此关键词的定义是一个<strong>存储类型（storage class）</strong>，用来控制变量的生命周期和可见性。</p><p><img src="/2017/06/01-A.png" alt="01-A"></p><p>static关键字会把一个变量的生命周期变成和程序的生命周期等同，这个感觉不用多介绍了，大家应该都懂的。</p><p>static变量对每个编译单元都是内部可见且分别独立的，这个的意思参照例子：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Public.h</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSInteger</span> staticInt = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClassA.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ClassA.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Public.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ClassA</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)test &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%zd"</span>, staticInt++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClassB.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ClassB.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Public.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ClassB</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)test &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%zd"</span>, staticInt++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ClassA.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ClassB.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    [ClassA test];</span><br><span class="line">    [ClassA test];</span><br><span class="line">    [ClassB test];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>一个编译单元简单来说就是一个.m文件，这里的<code>ClassA</code>和<code>ClassB</code>都引用了<code>Public.h</code>，但是因为这是两个编译单元，所以它们虽然都有<code>staticInt</code>这个静态变量，但是实际上是两个独立的静态变量，这两个独立的静态变量只对它们所在的文件内部可见。</p><h2 id="静态全局变量（static-global-variable）"><a href="#静态全局变量（static-global-variable）" class="headerlink" title="静态全局变量（static global variable）"></a>静态全局变量（static global variable）</h2><p>上述的例子就是一个静态全局变量，通常将变量定义在文件的顶部，这样就对整个文件都可见了。</p><p>你问我为什么定义在顶部的话，那是因为：</p><p><img src="/2017/06/01-B.png" alt="01-B"></p><p>C语言就是这样的啊……定义在中间，在这之前的代码就访问不到了。</p><p>但是有比较奇特的一点：</p><p><img src="/2017/06/01-C.png" alt="01-C"></p><p>ObjC里面定义在<code>@implementation</code>段内的静态全局变量，作用范围会从当前的<code>@implementation</code>开始。</p><h2 id="静态成员变量（static-member-variables）"><a href="#静态成员变量（static-member-variables）" class="headerlink" title="静态成员变量（static member variables）"></a>静态成员变量（static member variables）</h2><p>这是C++的概念，很可惜在ObjC中并没有这个概念。</p><p>在C++类的内部声明的静态变量会变成在这个类内部才能访问的静态成员变量。</p><p>但是在上一节中大家也看到了ObjC中在<code>@implementation</code>段内的仍然是静态全局变量。</p><p>在<code>@interface</code>段中声明静态变量则会直接报错：</p><p><img src="/2017/06/01-D.png" alt="01-D"></p><h2 id="静态局部变量（static-local-variables）"><a href="#静态局部变量（static-local-variables）" class="headerlink" title="静态局部变量（static local variables）"></a>静态局部变量（static local variables）</h2><p>定义在函数体内的为静态局部变量，和定义在函数内的普通局部变量一样，在函数外是不可见的。例子如下图：</p><p><img src="/2017/06/01-E.png" alt="01-E"></p><p>要注意这里的<code>staticInt = 0</code>是初始化，并不是赋值，仅会运行一次。</p><p>通常来说我们建立单例的时候就应该使用静态局部变量。另外很重要的一点，在创建单例的时候最好用<code>dispatch_once</code>方法避免多线程问题。</p><h1 id="Extern"><a href="#Extern" class="headerlink" title="Extern"></a>Extern</h1><h2 id="同文件的extern扩展"><a href="#同文件的extern扩展" class="headerlink" title="同文件的extern扩展"></a>同文件的extern扩展</h2><p>从纯C开始说起吧，因为同文件的extern一般来说只有纯C里需要：</p><p><img src="/2017/06/01-F.png" alt="01-F"></p><p>可以看到因为<code>int a = 0</code>写在了<code>main</code>函数之后，所以<code>main</code>函数是访问不到变量a的。</p><p><img src="/2017/06/01-G.png" alt="01-G"></p><p>这时候就要用到extern关键字，扩展变量的有效可见范围，就可以在<code>main</code>函数中访问到变量<code>a</code>了。</p><p>在ObjC中，我们几乎已经不需要用到这种用法了。</p><h2 id="外部变量（external-variable）"><a href="#外部变量（external-variable）" class="headerlink" title="外部变量（external variable）"></a>外部变量（external variable）</h2><p>参照<a href="https://en.wikipedia.org/wiki/External_variable" target="_blank" rel="noopener">维基百科</a>，所谓外部变量就是定义在函数体外的变量。通常会把外部变量统一定义在文件顶部，这样就免去上面说的用extern扩展的麻烦了。在这种情况下，在文件内所有函数里就都可以访问到这个变量了。</p><p>关于外部变量的编译相关原理细节在此就不多述，有兴趣的可以自行查阅资料。</p><h2 id="跨文件的extern扩展"><a href="#跨文件的extern扩展" class="headerlink" title="跨文件的extern扩展"></a>跨文件的extern扩展</h2><p>记得文章开始的截图么，extern关键字也是一个<strong>存储类型（storage class）</strong>。extern和static的不同点在于全程序共用一个变量而非每个编译单元有自己的独立变量，用了extern关键字之后变量将变得真正意义的全局可见。</p><p>为了方便理解，举个例子：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Public.m</span></span><br><span class="line"><span class="comment">// 注意这是.m文件！注意这是.m文件！注意这是.m文件！</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Public.h"</span></span></span><br><span class="line"><span class="built_in">NSInteger</span> externInt = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClassA.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ClassA.h"</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSInteger</span> externInt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ClassA</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)test &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%zd"</span>, externInt++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClassB</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ClassB.h"</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSInteger</span> externInt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ClassB</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)test &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%zd"</span>, externInt++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ClassA.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ClassB.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    [ClassA test];</span><br><span class="line">    [ClassA test];</span><br><span class="line">    [ClassB test];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>可以看到这时ClassA和ClassB引用到的externInt是同一个变量。</p><p>注意最开始的是<code>Public.m</code>而不是<code>Public.h</code>文件！extern的用法和static是略有不同的，定义变量时只要将变量在.m文件里常规的定义成外部变量即可，使用的时候在对应外部文件里直接extern扩展下即可使用。</p><p>通常情况下，我们是成对的这样.m文件和.h文件：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Public.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Public.h"</span></span></span><br><span class="line"><span class="built_in">NSInteger</span> externInt = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Public.h</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSInteger</span> externInt;</span><br></pre></td></tr></table></figure><p>这样外部文件只需要<code>#import &quot;Public.h&quot;</code>就可以直接引用到<code>externInt</code>了。</p><h1 id="Const"><a href="#Const" class="headerlink" title="Const"></a>Const</h1><p>参照<a href="https://en.wikipedia.org/wiki/Const_(computer_programming" target="_blank" rel="noopener">维基百科</a>)，通常习惯叫被const修饰的变量为常量，const是一个<strong>类型修饰词（type qualifier）</strong>，用来表示这个『变量』是不可修改的。</p><p><img src="/2017/06/01-H.png" alt="01-H"></p><p>可以看到只能在定义常量的时候进行初始化，在之后的代码里再进行值的修改就会报错。</p><p>值得一提的是，const定义的常量是在编译器就确定好值的。所以大部分需要编译期就确定值的语法里，常量都是可以使用的：</p><p><img src="/2017/06/05-D.png" alt="05-D"></p><p>这也是很多情况下推荐使用常量的原因之一。后面还会和宏定义做个对比，在那之前先继续说常量的定义姿势。</p><h2 id="复杂的常量定义"><a href="#复杂的常量定义" class="headerlink" title="复杂的常量定义"></a>复杂的常量定义</h2><p>对指针变量怎么用const关键字应该是最绕的部分了，简单概括的话就是const修饰的右侧内容无法被修改。详细的直接看下面的例子：</p><p><img src="/2017/06/05-E.png" alt="05-E"></p><p>如果想要完全不能修改，采用d的策略就好了。通常情况下定义指针型常量都是字串型的，因为NSString型变量本身值是不可以修改的，所以一般来说定义如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> constString = <span class="string">@"test"</span>;</span><br></pre></td></tr></table></figure><p>这样就可以保证别人不能写<code>constString = xxx;</code>了。</p><h1 id="Define"><a href="#Define" class="headerlink" title="Define"></a>Define</h1><p>define并不是一个C语言的关键字，它只是一个预处理指令，在进行编译之前会做原封原样的替换。</p><h2 id="原封原样的替换"><a href="#原封原样的替换" class="headerlink" title="原封原样的替换"></a>原封原样的替换</h2><p>简单来说这两段代码是一毛一样的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define DefineInt 1</span></span><br><span class="line"><span class="keyword">int</span> defineInt = DefineInt;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> defineInt = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>关于原封原样替换的解释，下面这个例子应该是最常用的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define DefineInt 1 + 2</span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%zd"</span>, DefineInt * <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为7，因为实际上代码等同于：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%zd"</span>, <span class="number">1</span> + <span class="number">2</span> * <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出来『原封原样』是什么意思了吧？define的内容并不会成为一个单元，而只是原样的替换而已。当然原样替换并不是define的缺点，而是一个特性。</p><h2 id="定义的值无类型"><a href="#定义的值无类型" class="headerlink" title="定义的值无类型"></a>定义的值无类型</h2><p><img src="/2017/06/05-A.png" alt="05-A"></p><p>上面的例子可以看出来宏定义的值类型十分灵活，所以在上面的代码里第7行和第8行都不会出警告，而常量因为包含明确指定的类型就会出警告。</p><p>任何事情也都有双面性，在更需要明确的类型检查时，这个特性就会成为一个隐患。当然其实也有办法可以处理类型检查的问题：</p><p><img src="/2017/06/05-B.png" alt="05-B"></p><p>在面对更复杂的场景时，这种写法还是可能有一些别的问题的。在需要类型检查时，建议使用常量来代替宏定义。</p><h2 id="无法处理成指针"><a href="#无法处理成指针" class="headerlink" title="无法处理成指针"></a>无法处理成指针</h2><p>参照下面的例子（警告的地方是因为常量指针和变量指针还是略有不同的）：</p><p><img src="/2017/06/05-C.png" alt="05-C"></p><p>因为宏定义只是原封原样替换，所以理所当然编译器不会为其分配地址，所以是无法做指针操作的。</p><p>在面对一些需要传递指针的场景，宏定义的值无法直接使用。</p><h2 id="对debug不友好"><a href="#对debug不友好" class="headerlink" title="对debug不友好"></a>对debug不友好</h2><p>debug的时候上面的DefineInt是无法在调试台显示的，只能自己去源代码里查阅定义的值是多少。</p><h2 id="可能被覆盖定义"><a href="#可能被覆盖定义" class="headerlink" title="可能被覆盖定义"></a>可能被覆盖定义</h2><p>这点真的很重要，<strong>define是可以被undefine的</strong>，然后再重新定义成别的值。如果团队里的成员沟通协作出现问题，同名的define覆盖了别人定义的值，会出很诡异的甚至可能灾难性的问题。</p><h1 id="Const配合Extern导出外界不可以修改的常量"><a href="#Const配合Extern导出外界不可以修改的常量" class="headerlink" title="Const配合Extern导出外界不可以修改的常量"></a>Const配合Extern导出外界不可以修改的常量</h1><p>首先参照下系统提供的一些extern导出示例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NSError.h</span></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">NSLocalizedDescriptionKey</span>;             <span class="comment">// NSString</span></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">NSLocalizedFailureReasonErrorKey</span>;      <span class="comment">// NSString</span></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">NSLocalizedRecoverySuggestionErrorKey</span>; <span class="comment">// NSString</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UIWindow.h</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="keyword">const</span> <span class="built_in">UIWindowLevel</span> <span class="built_in">UIWindowLevelNormal</span>;</span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="keyword">const</span> <span class="built_in">UIWindowLevel</span> <span class="built_in">UIWindowLevelAlert</span>;</span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="keyword">const</span> <span class="built_in">UIWindowLevel</span> <span class="built_in">UIWindowLevelStatusBar</span> __TVOS_PROHIBITED;</span><br></pre></td></tr></table></figure><p><code>FOUNDATION_EXPORT</code>和<code>UIKIT_EXTERN</code>都是iOS SDK定义的宏，主要是处理了C++引用时要用extern “C”的问题，建议大家提供的常量导出是尽量用这两个宏。</p><p>关于为什么不使用define，在前文的对比中大概的讲解了。</p><p>不使用static配合const的原因在于，static提供的常量会产生很多副本，而且static本身从设计初衷上就不应该是配合const使用的。</p><p>extern导出的常量有一个优点就是不会直接展示出具体的常量值是多少，因为实际的初始化是在.m文件里，在对外导出library或者framework的时候.h里面就不会包含这个初始值。（当然用户还是能知道值是多少的就是。）</p><p>extern导出的常量还有一个优点，理论上用extern导出的字串常量，在比对时都可以直接用<code>==</code>来直接进行比对而不需要使用<code>isEqualToString</code>。但是考虑代码的健壮性最好仍使用<code>isEqualToString</code>来进行比对，毕竟现在的设备CPU已经不差这么点性能优化了。</p><p>所以从最后来说最合适的导出手段，也就是如上iOS SDK导出常量的方式了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;讲道理这些用处都完全不一样，为什么大家喜欢一起讲……那么既然都喜欢一起讲，我也写在一起好了……&lt;/p&gt;
&lt;p&gt;另外值得一提的是，这些其实就是纯C的东西，并不是ObjC才特有的。&lt;/p&gt;
    
    </summary>
    
      <category term="ObjC" scheme="http://blog.harrisonxi.com/categories/ObjC/"/>
    
    
      <category term="ObjC" scheme="http://blog.harrisonxi.com/tags/ObjC/"/>
    
      <category term="keyword" scheme="http://blog.harrisonxi.com/tags/keyword/"/>
    
      <category term="define" scheme="http://blog.harrisonxi.com/tags/define/"/>
    
      <category term="static" scheme="http://blog.harrisonxi.com/tags/static/"/>
    
      <category term="extern" scheme="http://blog.harrisonxi.com/tags/extern/"/>
    
      <category term="const" scheme="http://blog.harrisonxi.com/tags/const/"/>
    
      <category term="常量" scheme="http://blog.harrisonxi.com/tags/%E5%B8%B8%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>git基本工作流及rebase介绍</title>
    <link href="http://blog.harrisonxi.com/2017/03/git%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%8F%8Arebase%E4%BB%8B%E7%BB%8D.html"/>
    <id>http://blog.harrisonxi.com/2017/03/git基本工作流程及rebase介绍.html</id>
    <published>2017-03-25T16:00:00.000Z</published>
    <updated>2018-06-05T03:52:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>扩展阅读：<a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">A successful Git branching model</a></p><h1 id="最原始的单分支工作流"><a href="#最原始的单分支工作流" class="headerlink" title="最原始的单分支工作流"></a>最原始的单分支工作流</h1><p><img src="/2017/03/25-A.png" alt="25-A"></p><p>这是在单人单版本线状况下，最简单的工作流了：所有的代码在一个master分支上提交，需要发布的时候直接在master分支发布新版本。</p><a id="more"></a><h1 id="开发分支与发布分支的分离"><a href="#开发分支与发布分支的分离" class="headerlink" title="开发分支与发布分支的分离"></a>开发分支与发布分支的分离</h1><p>每一种工作流的进化，都是为了解决一个实际工作中会遇到的问题。我们首先会遇到的问题就是：</p><ol><li>开发中的分支可能不稳定，外部人员不明我们工作流的情况下，需要一个最新的稳定分支，却不知从哪获得。</li><li>开发人员排查已发布线上版本问题时，不知道最新的已发布代码位置在哪。</li></ol><p><img src="/2017/03/25-B.png" alt="25-B"></p><p>在此需求下，进化出了develop分支：开发时所有的代码在develop分支提交，在功能稳定需要发布的时候向master进行一次合并并发布，保证master始终是最后一次发布的稳定的代码。</p><h1 id="多人协作下的开发分支分离"><a href="#多人协作下的开发分支分离" class="headerlink" title="多人协作下的开发分支分离"></a>多人协作下的开发分支分离</h1><p>现在项目组人员增加了，所有人在同一个develop分支提交代码的结果就是：</p><ol><li>每次提交都可能要处理冲突。</li><li>develop可能随时存在不稳定的功能或者做了一半的功能。</li></ol><p>当然其实git是能解决这个问题的，因为commit是产生在本地的，你可以选择一直不push代码，在完成完整功能之后再进行push操作并进行冲突处理。</p><p>但是要记住代码不存一份副本是风险很高的，就算你自己硬盘没有坏过应该也听说过被硬盘损坏所支配的恐惧。越大的功能存在的风险就越高，一个月才能做完的功能临做完准备push的时候电脑坏了，那画面太美不敢想。</p><p>git的伟大之处就在于多处同步，无论服务器和研发人员的电脑坏了几个，只要还有一个完好的副本，就能随时满血复活。</p><p>有点扯远了，那么为了解决上述单develop分支的弊端，建立新的方案：</p><p><img src="/2017/03/25-C.png" alt="25-C"></p><p>每个人基于develop分支开出自己使用的develop分支副本，在此分支上进行开发工作，自行选择合适的时机处理冲突合回主干develop。这样的方案，一定程度可以解决多人协作的问题。</p><h1 id="基于需求拆分分支的需要及规范"><a href="#基于需求拆分分支的需要及规范" class="headerlink" title="基于需求拆分分支的需要及规范"></a>基于需求拆分分支的需要及规范</h1><p>随着需求数量的增多，以及单个需求规模和复杂度的增大，上述多develop分支方案也面临着新的挑战：</p><ol><li>复杂的需求可能出现较多的bug，需要针对单个功能需求进行QA验证后再进行合并，维持开发主干稳定性。</li><li>被『这个需求这期不上了』所支配的恐惧。</li></ol><p>相信大家也或多或少的遇到过这样的问题，那么在这种情况下我们的每个分支最好只包含一个单独的功能需求：</p><p><img src="/2017/03/25-D.png" alt="25-D"></p><p>如上图所示，每一个feature分支代表一个单独的功能需求，这样的方案带来的优势：</p><ol><li>方便在feature分支合并入主干前进行QA和Code Review等工作。</li><li>『这个需求这期不上了』时只要不合并对应feature分支到主干即可。</li></ol><h1 id="发布准备分支的分离"><a href="#发布准备分支的分离" class="headerlink" title="发布准备分支的分离"></a>发布准备分支的分离</h1><p>上述各种方案最终都是依赖develop分支来生成总包进行QA验证，最后发布版本的。在这种情况下，发布期间就必须锁定develop分支，只能push修复总包问题的提交，之外的提交均不可以push。这就带来了问题：</p><ol><li>无法处理多版本需要同时发布的需要。</li><li>对其他依赖develop分支进行的工作产生阻塞。</li></ol><p><img src="/2017/03/25-E.png" alt="25-E"></p><p>在这种情况下就诞生了全新的release分支：在需要发布的功能需求都已经合入develop之后，从develop分支开出独立的release分支，进行QA、问题修复并持续构建总包做好发布前的准备工作。这样做带来的优势：</p><ol><li>不阻塞develop分支的后续工作。</li><li>需要发布的时候开出一个新的release分支即可，可以开出多个release分支适应多版同发的需要。</li></ol><h1 id="线上版本问题紧急修复"><a href="#线上版本问题紧急修复" class="headerlink" title="线上版本问题紧急修复"></a>线上版本问题紧急修复</h1><p>现在线上版本出了重大问题，需要紧急修复之后发布一个新的版本！develop分支带了一些别的提交，可能是不稳定的，显然并不适合用develop去发布一个新的版本。这时候大家可以回想下当初把master和develop分离的初衷了，master分支到了出马的时候。</p><p><img src="/2017/03/25-F.png" alt="25-F"></p><p>我们其实可以在master分支直接提交修复。但是这会有些问题：</p><ol><li>修复还是要被验证的，并不一定一个修复就能完全的修好问题。</li><li>我们对master的定义是每一个节点代表一个发出去的版本，master始终维持的是线上最后一个版本的状态，所以最好是确认发布之后再向master合并。</li></ol><p>所以这里诞生了hotfix分支，我们从master开出hotfix分支，进行QA验证后重新再发一个紧急修复版本，然后将hotfix分支合并回master和develop主干。</p><p>当然方案并不是唯一的，在不违反规范且上一个release分支能被找到的情况下，这样也没什么问题：</p><p><img src="/2017/03/25-G.png" alt="25-G"></p><h1 id="Fork-amp-Pull-Request式工作流"><a href="#Fork-amp-Pull-Request式工作流" class="headerlink" title="Fork &amp; Pull Request式工作流"></a>Fork &amp; Pull Request式工作流</h1><p><img src="/2017/03/26-A.png" alt="26-A"></p><p>一图流……每个团队都有一个git副本，每个团队的git副本按照自己的工作流习惯来进行工作。在需要进行合并的时候，其他团队merge主团队的代码。在需要向主团队提交代码时，提出对应的pull request。这个暂不多述。</p><h1 id="关于merge产生的commit"><a href="#关于merge产生的commit" class="headerlink" title="关于merge产生的commit"></a>关于merge产生的commit</h1><p><img src="/2017/03/25-H.png" alt="25-H"></p><p>如图所示，d-1表示在develop分支进行的第一个commit，2-1表示在feature2分支进行的第一个commit，m-1表示第一次用merge方式合并代码产生的合并commit。这个图示的方式在后面会用到。</p><p>在常规工作中，我们是更建议使用merge方式来合并代码的，merge方式每一次合并会产生一个新的commit（需要禁用Fast Forward）并能忠实的反映每一个分支的合并历史。</p><h1 id="使用rebase可以解决的问题"><a href="#使用rebase可以解决的问题" class="headerlink" title="使用rebase可以解决的问题"></a>使用rebase可以解决的问题</h1><p><img src="/2017/03/25-I.png" alt="25-I"></p><p>如图所示，大家可以看到merge模式带来的困扰：</p><ol><li>过多的合并commit，对强迫症患者不友好。</li><li>如图情况下想要提取2-1和2-2两个commit加在一起修改了什么，较为困难。</li></ol><p>（注：其实图示情况下将HEAD指向d-3，再尝试将m-3位置merge过来即可获得2-1和2-2一起修改了什么。但是更复杂的情况下，merge操作并不能处理出结果。）</p><p>这种时候就可以用到rebase方式进行代码合并了。rebase操作的结果示意如下图：</p><p><img src="/2017/03/25-J.png" alt="25-J"></p><p>可以看到feature2分支直接变成了基于m-1位置开出的分支，这也是rebase这个词的含义的直接体现。如果后续继续进行rebase操作，还可以得到结果：</p><p><img src="/2017/03/25-K.png" alt="25-K"></p><p>这样分支结构就会变得清晰无比，而对应分支的commit连贯性也变得十分的强。</p><h1 id="rebase带来的问题"><a href="#rebase带来的问题" class="headerlink" title="rebase带来的问题"></a>rebase带来的问题</h1><ol><li>多人协作灾难</li></ol><p>但是不知大家是否注意到一点，2-1对应的commit在rebase之后变成了2-2，2-2和2-3对应的commit在rebase之后又变成了2-4和2-5。是的，其实rebase之后会得到全新的commit，feature2分支也会变成一个全新的分支。如果这个时候你已经将feature2分支push到过远程服务器，那么你本地的分支和远程的分支势必是冲突的，只能通过git push –force指令来将本地的分支强行覆盖至服务器上的对应分支。如果服务器上的对应分支被别人pull过，那么恭喜你们，你们将遇到各种蛋疼和诡异的合并问题。所以rebase操作必须在自己个人使用的分支上才能进行，如果在公共分支上操作就只能通知大家删掉各自已经拉取的本地分支后重新拉取远程分支了。</p><ol><li>破坏commit历史</li></ol><p>feature2分支每次rebase完之后得到新的commit，看上去也会变成从新的位置开出的分支。这种模式和merge相比较的问题就是，无法真实的反映出feature2分支究竟是从哪开出来的。所以各分支合并回develop主干的时候，一定要使用merge方式，保留一个merge commit来用以识别合入操作的时间点。</p><ol><li>破坏合并冲突历史</li></ol><p>在merge的时候遇到冲突，对应的merge commit里会列出冲突的文件，以供之后回朔历史的时候找到问题。而rebase的时候，不会在commit信息里展示出曾经遇到过的冲突，遇到问题时只能人肉一点点排查了，基本上是无解的状态。</p><h1 id="在SourceTree中进行rebase"><a href="#在SourceTree中进行rebase" class="headerlink" title="在SourceTree中进行rebase"></a>在SourceTree中进行rebase</h1><p>综上所述，使用rebase时一定要在深入理解的情况下，谨慎操作才可以。在确保你了解并打算使用rebase之后，我来介绍一下在SourceTree中该如何进行操作。</p><p>我建立了一个空白的git库，初始化commit在文件里写入了a=1，在develop提交一次将文件内容改为a=2，在feature分支提交了一次将文件内容改为a=3。</p><p><img src="/2017/03/26-B.png" alt="26-B"></p><p>如图所示，我现在身处feature分支，右键点击要合并的位置，选择『Rebase…』。这时候如果没有冲突的话，reabse就会直接完成了。可是喜闻乐见的是我这两个分支肯定是有冲突的，那么我们就去解决对应的冲突。解决完了之后要在SourceTree的主菜单里选择『Actions』-&gt;『Continue Rebase』，这时候Rebase就会继续完成。最后我们会得到结果：</p><p><img src="/2017/03/26-C.png" alt="26-C"></p><p>可以看到整个分支结构变了，feature分支的commit对应的hash和提交时间都变了，并没有展示产生过冲突，而是直接显示我把『a=2』改成了『a=3』。</p><h1 id="使用rebase的规则"><a href="#使用rebase的规则" class="headerlink" title="使用rebase的规则"></a>使用rebase的规则</h1><p>先做好例子用来讲后面的规则，这次也用SourceTree截图直接示意了：</p><p><img src="/2017/03/30-A.png" alt="30-A"></p><p>基于上图的状态，在b3分支对b2分支做rebase操作。这时候可以看到rebase处理冲突的位置和merge是不一样的，rebase处理的是b2最晚一个commit（a=3）和b3最早一个commit（a=4）之间的冲突：</p><p><img src="/2017/03/30-B.png" alt="30-B"></p><p>要注意下上面说的最晚一个commit和最早一个commit，是相对于这两个分支的<strong>公共父commit</strong>（develop分支的a=1）来说的。</p><p>处理完了之后会看到现在的状态，b3看上去是从b2开出来的分支了：</p><p><img src="/2017/03/30-C.png" alt="30-C"></p><p>这时候再对b1分支做一次rebase操作，见证奇迹的时刻就到了：</p><p><img src="/2017/03/30-D.png" alt="30-D"></p><p>为什么会产生这种结果呢？因为b3在第一次rebase之后，相对于b1来说最早的commit已经变成了a=3，所以再对b1做rebase操作之后就直接把a=3挂在b1分支之后了。</p><p>直接用现象来反推规则就是，rebase应该始终<strong>基于同一个分支</strong>（当初你开出分支所基于的base分支，一般来说是develop分支）进行操作。如果针对不同的分支反复进行rebase，中间几次操作『挂上』的commit们（比如这里的a=3），就会大串大串重复的出现在你的commit历史里。</p><h1 id="使用squash合并多个commit"><a href="#使用squash合并多个commit" class="headerlink" title="使用squash合并多个commit"></a>使用squash合并多个commit</h1><p>就拿上面我例子里的几个commit举例，我觉得这几个commit太脑残了，就改一个a的值反反复复改了3次，能不能把它们合并成一个commit（在假设只有feature分支的情况下）？</p><p>答案是可以的！squash可以拯救你！强迫症有救了！</p><p><img src="/2017/03/25-L.png" alt="25-L"></p><p>如上图所示意，squash所做的操作就是把3个commit压缩成了一个新的commit。squash的弊端和rebase类似，会丢失很多信息。merge的时候也可以进行squash操作，一般在并不在乎commit历史的情况下才可以使用squash方式进行merge。通常情况下我们是在rebase的时候使用squash，处理自己的分支让其commit历史更加清晰干净。</p><h1 id="在SourceTree中进行squash"><a href="#在SourceTree中进行squash" class="headerlink" title="在SourceTree中进行squash"></a>在SourceTree中进行squash</h1><p>说了这么多，该怎么操作呢？我这就拿一个例子来示范。</p><p>以下是我们项目组最新的一个release分支，存在反复修改build号和修改依赖分支的操作：</p><p><img src="/2017/03/26-D.png" alt="26-D"></p><p>我想要把上面4个commit合并成2个，那么就右键点击第5个commit选择图中所示的『Rebase xxx interactively…』菜单，之后会打开一个新窗口：</p><p><img src="/2017/03/26-E.png" alt="26-F"></p><p>选中最上方的commit 1d19972，然后点击下方的『Squash with previous』按钮就可以把两个commit合并成一个了，如上图所示。继续操作可以把下方两个commit也合并成一个。可以选中对应的commit点击下方的『Edit message』进行commit信息编辑。完成之后点击『OK』就搞定啦：</p><p><img src="/2017/03/26-F.png" alt="26-F"></p><p>可以看到合并后得到了两个新的commit，但是本地分支已经和远程分支渐行渐远。这里就是做个操作的示意，这种情况下是不建议强制push代码到远程的。</p><h1 id="总结和广告时间"><a href="#总结和广告时间" class="headerlink" title="总结和广告时间"></a>总结和广告时间</h1><p>画图画了一天，打字打了一天，总算是把本文写完了。本文总结了git工作流可以解决的问题，以及git常见操作优劣势及适用的场景，剩下的就是看大家自己灵活配合使用来解决各种问题了，祝大家好运。</p><p>推荐一下<a href="https://www.processon.com/i/57d29512e4b08cbf6ce17376" target="_blank" rel="noopener">ProcessOn</a>，本文中流程图均使用此网站绘制，功能满足各种日常需要，而且因为是国内团队的产品速度也很优秀。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;扩展阅读：&lt;a href=&quot;http://nvie.com/posts/a-successful-git-branching-model/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A successful Git branching model&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;最原始的单分支工作流&quot;&gt;&lt;a href=&quot;#最原始的单分支工作流&quot; class=&quot;headerlink&quot; title=&quot;最原始的单分支工作流&quot;&gt;&lt;/a&gt;最原始的单分支工作流&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2017/03/25-A.png&quot; alt=&quot;25-A&quot;&gt;&lt;/p&gt;
&lt;p&gt;这是在单人单版本线状况下，最简单的工作流了：所有的代码在一个master分支上提交，需要发布的时候直接在master分支发布新版本。&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="http://blog.harrisonxi.com/categories/git/"/>
    
    
      <category term="git" scheme="http://blog.harrisonxi.com/tags/git/"/>
    
      <category term="工作流" scheme="http://blog.harrisonxi.com/tags/%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    
      <category term="workflow" scheme="http://blog.harrisonxi.com/tags/workflow/"/>
    
      <category term="rebase" scheme="http://blog.harrisonxi.com/tags/rebase/"/>
    
      <category term="merge" scheme="http://blog.harrisonxi.com/tags/merge/"/>
    
      <category term="squash" scheme="http://blog.harrisonxi.com/tags/squash/"/>
    
      <category term="SourceTree" scheme="http://blog.harrisonxi.com/tags/SourceTree/"/>
    
  </entry>
  
  <entry>
    <title>NSURLErrorDomain的-1005错误</title>
    <link href="http://blog.harrisonxi.com/2017/03/NSURLErrorDomain%E7%9A%84-1005%E9%94%99%E8%AF%AF.html"/>
    <id>http://blog.harrisonxi.com/2017/03/NSURLErrorDomain的-1005错误.html</id>
    <published>2017-03-17T16:00:00.000Z</published>
    <updated>2018-06-05T03:52:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于HTTP-1-1和HTTP长连接"><a href="#关于HTTP-1-1和HTTP长连接" class="headerlink" title="关于HTTP 1.1和HTTP长连接"></a>关于HTTP 1.1和HTTP长连接</h1><p>HTTP 1.0中，默认进行的都是短连接。一个HTTP请求会产生一个TCP连接，请求结束后就会关闭这个TCP连接。而自HTTP 1.1开始，默认进行的都是<a href="https://zh.wikipedia.org/wiki/HTTP%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5" target="_blank" rel="noopener">长连接</a>。在一个HTTP请求结束之后，客户端和服务端之间的TCP连接并不会立即断开，而是按照约定的Keep-Alive时长维持一定时间的连接状态。这样在下一次HTTP请求发生时，如果TCP连接还存在就会复用之前的TCP连接，省去重新建立TCP连接的时间。</p><a id="more"></a><h1 id="iOS的-1005错误"><a href="#iOS的-1005错误" class="headerlink" title="iOS的-1005错误"></a>iOS的-1005错误</h1><p>我们的团队是在使用SDWebImage的时候遇到这个问题的，经搜索发现早在iOS 8时代就有人在使用AFNetworking的时候遇到这个问题：<a href="http://stackoverflow.com/questions/25372318/error-domain-nsurlerrordomain-code-1005-the-network-connection-was-lost" target="_blank" rel="noopener">NSURLErrorDomain的-1005错误</a></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error Domain=<span class="built_in">NSURLErrorDomain</span> Code=<span class="number">-1005</span> <span class="string">"The network connection was lost."</span></span><br></pre></td></tr></table></figure><p>具体的原因参照<a href="http://stackoverflow.com/a/25996971/2562905" target="_blank" rel="noopener">这个回答</a>的描述：NSURLRequest的实现有问题，在维持长连接的时候维持时长超过了服务器约定的时长，在第二次HTTP请求准备复用TCP连接的时候实际上连接已经被服务器断开了。</p><p>我没有去调研&amp;测试NSURLRequest的实现是不是真的有问题，倒是觉得移动设备的一些极端网络情况可能的确会面临这样的问题。</p><p>那么接下来就是要解决这个问题。</p><h1 id="由服务端解决这个问题"><a href="#由服务端解决这个问题" class="headerlink" title="由服务端解决这个问题"></a>由服务端解决这个问题</h1><h2 id="1-提高服务器Keep-Alive时长至30秒以上"><a href="#1-提高服务器Keep-Alive时长至30秒以上" class="headerlink" title="1. 提高服务器Keep-Alive时长至30秒以上"></a>1. 提高服务器Keep-Alive时长至30秒以上</h2><p>我在简书上也看到有人将Keep-Alive时长设置成了60秒，对应问题可以解决。</p><p>但是这个设置对于服务器是有风险的。延长Keep-Alive时长无疑会浪费服务器的性能，毕竟同时需要维持的连接数变多了。很多用户其实也不需要这么长时间的长连接。所以这个方案需要斟酌之后再确定要不要实行。</p><h2 id="2-针对iOS客户端禁用长连接"><a href="#2-针对iOS客户端禁用长连接" class="headerlink" title="2. 针对iOS客户端禁用长连接"></a>2. 针对iOS客户端禁用长连接</h2><p>不同的服务器设置方法不一样，具体方法就不多说了。</p><p>这个方案的风险在于，抛弃了长连接会对HTTP请求的速度产生些许影响。</p><h1 id="由客户端解决这个问题"><a href="#由客户端解决这个问题" class="headerlink" title="由客户端解决这个问题"></a>由客户端解决这个问题</h1><h2 id="1-重新实现HTTP请求底层，降低客户端Keep-Alive时长"><a href="#1-重新实现HTTP请求底层，降低客户端Keep-Alive时长" class="headerlink" title="1. 重新实现HTTP请求底层，降低客户端Keep-Alive时长"></a>1. 重新实现HTTP请求底层，降低客户端Keep-Alive时长</h2><p>这是个大工程，我们需要写一个完备的底层，使客户端的Keep-Alive时长比服务端传回的时长短一些。这样的话就更低概率甚至不会出现服务端比客户端早断开TCP连接的情况。在出现长连接断开的情况下，底层也应该负责进行一次重试，再开一个新的TCP连接进行HTTP请求。</p><h2 id="2-由业务层或框架层重试HTTP请求"><a href="#2-由业务层或框架层重试HTTP请求" class="headerlink" title="2. 由业务层或框架层重试HTTP请求"></a>2. 由业务层或框架层重试HTTP请求</h2><p>出现错误的时候重试一次HTTP请求就好。在框架或者业务代码里仍然用NSURLRequest实现请求，捕获到-1005错误的时候进行一次重试。虽然说总体用时会更长，但是正确的结果更加重要些。</p><h1 id="SDWebImage里的问题"><a href="#SDWebImage里的问题" class="headerlink" title="SDWebImage里的问题"></a>SDWebImage里的问题</h1><p>在SDWebImage中遇到此问题的现象：有些图片一旦请求失败一次就再也没法刷出来。</p><p>归根结底在于SDWebImage维护了一个<strong>failedURLs</strong>列表，请求失败的图片URL都会被加入到这个表中。下次请求的时候如果没有带上SDWebImageRetryFailed选项，SDWebImage就会自动忽略这些URL直接返回错误。</p><p>某些特殊的网络错误会被判定是网络连接问题，请求失败时SDWebImage不会将图片URL加入<strong>failedURLs</strong>列表。而这个特殊的网络错误列表里之前没有包含-1005错误，导致出现-1005错误后这些图片就再也不会被重加载。</p><p>好在2个月前（2017-1-6）有人提交了对应的修改：<a href="https://github.com/rs/SDWebImage/commit/57502a9d1d3044a2c2f7969e5241619a697625fb" target="_blank" rel="noopener">add a network error situation</a>，我们的SDWebImage是太久没更新了才会遇到这个问题。</p><h1 id="YYWebImage里的实现"><a href="#YYWebImage里的实现" class="headerlink" title="YYWebImage里的实现"></a>YYWebImage里的实现</h1><p>参照<a href="https://github.com/ibireme/YYWebImage/blob/master/YYWebImage/YYWebImageOperation.m" target="_blank" rel="noopener">YYWebImageOperation</a>类的实现。</p><p>和SDWebImage实现不同的是：</p><ol><li>YYWebImage默认是不会记录<strong>URLInBlackList</strong>的，只有带上YYWebImageOptionIgnoreFailedURL选项，请求图片失败时才会把图片URL加入<strong>URLInBlackList</strong>。</li><li>YYWebImage默认是会重试<strong>URLInBlackList</strong>的，必须带上YYWebImageOptionIgnoreFailedURL选项，才会忽略URLInBlackList中的图片URL。</li></ol><p>介于以上原因，实际上按照默认行为使用YYWebImage时如果加载图片失败，下一次加载还是会重试的，所以不会导致图片一直刷不出的严重问题。</p><p>当然YYWebImage处理的网络连接问题列表里也没有包含-1005错误，所以我已经提了<a href="https://github.com/ibireme/YYWebImage/pull/172" target="_blank" rel="noopener">pull request</a>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于大部分团队来说，应该还是用客户端方案2来处理比较方便。</p><p>需要做的就是在客户端请求服务API和图片资源时，出现-1005错误就进行一次重试。</p><p>当然如果使用了以上图片库，记得更新下最新版或者手动加上对-1005错误的处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于HTTP-1-1和HTTP长连接&quot;&gt;&lt;a href=&quot;#关于HTTP-1-1和HTTP长连接&quot; class=&quot;headerlink&quot; title=&quot;关于HTTP 1.1和HTTP长连接&quot;&gt;&lt;/a&gt;关于HTTP 1.1和HTTP长连接&lt;/h1&gt;&lt;p&gt;HTTP 1.0中，默认进行的都是短连接。一个HTTP请求会产生一个TCP连接，请求结束后就会关闭这个TCP连接。而自HTTP 1.1开始，默认进行的都是&lt;a href=&quot;https://zh.wikipedia.org/wiki/HTTP%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;长连接&lt;/a&gt;。在一个HTTP请求结束之后，客户端和服务端之间的TCP连接并不会立即断开，而是按照约定的Keep-Alive时长维持一定时间的连接状态。这样在下一次HTTP请求发生时，如果TCP连接还存在就会复用之前的TCP连接，省去重新建立TCP连接的时间。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://blog.harrisonxi.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://blog.harrisonxi.com/tags/iOS/"/>
    
      <category term="NSURLErrorDomain" scheme="http://blog.harrisonxi.com/tags/NSURLErrorDomain/"/>
    
      <category term="-1005" scheme="http://blog.harrisonxi.com/tags/1005/"/>
    
      <category term="长连接" scheme="http://blog.harrisonxi.com/tags/%E9%95%BF%E8%BF%9E%E6%8E%A5/"/>
    
      <category term="HTTP" scheme="http://blog.harrisonxi.com/tags/HTTP/"/>
    
      <category term="SDWebImage" scheme="http://blog.harrisonxi.com/tags/SDWebImage/"/>
    
      <category term="YYWebImage" scheme="http://blog.harrisonxi.com/tags/YYWebImage/"/>
    
  </entry>
  
  <entry>
    <title>给nginx从Let&#39;s Encrypt申请个SSL证书</title>
    <link href="http://blog.harrisonxi.com/2017/02/%E7%BB%99nginx%E4%BB%8ELet&#39;s%20Encrypt%E7%94%B3%E8%AF%B7%E4%B8%AASSL%E8%AF%81%E4%B9%A6.html"/>
    <id>http://blog.harrisonxi.com/2017/02/给nginx从Let&#39;s Encrypt申请个SSL证书.html</id>
    <published>2017-02-25T16:00:00.000Z</published>
    <updated>2018-06-05T03:52:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>网站HTTPS化是迟早的事情了，一是国外各大厂都在推行HTTPS化（例如苹果），一是国内HTTP被劫持篡改的现象越来越严重了。</p><p>现在SSL证书也有免费的了，所以我们可以考虑给自己的站点申请一个免费的证书，让它也支持起HTTPS来。</p><p>国外两大提供免费SSL证书的机构就是<a href="https://letsencrypt.org/" target="_blank" rel="noopener">Let’s Encrypt</a>和StartSSL了（别问我为什么不说国内的），然后StartSSL也是因为和国内的某厂产生了关系变得不可信任了，所以今天我能选择的就只有这么一家了。</p><a id="more"></a><h1 id="从Let’s-Encrypt申请证书"><a href="#从Let’s-Encrypt申请证书" class="headerlink" title="从Let’s Encrypt申请证书"></a>从Let’s Encrypt申请证书</h1><p>文中之后就简称Let’s Encrypt为LE了。</p><p>LE只提供了DV（Domain Validation，域名验证）类型的SSL证书，只要你持有域名，就可以在验证通过后得到对应域名可用的SSL证书。具体的验证方法，就是在你域名的网站下建立一个<strong>/.well-known/acme-challenge</strong>文件，LE会去访问这个文件确认你的确持有这个域名。这里有个问题就是<strong>.well-known</strong>是用点开头的，在Linux中是隐藏文件，需要配置好你的nginx保证从外网可以访问到这个路径先。</p><p>整个过程还是比较繁琐的，所以LE推荐我们使用工具<a href="https://certbot.eff.org/" target="_blank" rel="noopener">Certbot</a>来搞定这件事。我的VPS是CentOS 6的，所以在Certbot首页选择好CentOS 6和nginx之后，打开了具体的<a href="https://certbot.eff.org/#centos6-nginx" target="_blank" rel="noopener">安装介绍页</a>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.eff.org/certbot-auto</span><br><span class="line">chmod a+x certbot-auto</span><br></pre></td></tr></table></figure><p>在想要安装Certbot的路径下执行上述指令，就可以得到可执行文件centbot-auto了。这个文件神通广大，可以自动安装各种需要的依赖。装好了它之后，Certbot推荐我们使用<a href="https://certbot.eff.org/docs/using.html#webroot" target="_blank" rel="noopener">webroot插件</a>来获得证书。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./certbot-auto certonly --webroot -w /var/www/example -d example.com -d www.example.com -w /var/www/thing -d thing.is -d m.thing.is</span><br></pre></td></tr></table></figure><p>这是一个示例的指令。其中<strong>/var/www/example</strong>是第一个虚拟主机在VPS上的根路径，后面的<strong>example.com</strong>和<strong>www.example.com</strong>就是对应的已绑定的域名，也就是-d参数对应的域名会向前取最近一个-w参数对应的根路径。这样Certbot就会在<strong>/var/www/example</strong>路径下创建<strong>/.well-known/acme-challenge</strong>文件，然后通知LE去验证，最后获得签名好的SSL证书存在本地，最后删除刚刚创建的验证用文件并输出结果。</p><p>我安装的nginx默认虚拟主机根路径在/usr/share/nginx下，我改了个名，所以指令是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./certbot-auto certonly --webroot -w /usr/share/nginx/harrisonxi.com -d harrisonxi.com</span><br></pre></td></tr></table></figure><p>确认后certbot-auto会调用yum安装各种依赖，都确认进行安装就好。</p><p>接下来会需要输入你的email地址，同意LE的协议，确认是否把email地址分享给EFF。</p><p>三步完成后没有什么问题应该就可以看到Congratulations的提示了，然后信息里也会提到你的证书存在哪里。</p><h1 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h1><p>nginx的配置文件一般是在/etc/nginx路径下，打开这个路径下的nginx.conf，可以看到实际上它是从其他文件import了server配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，就要再去/etc/nginx/conf.d路径下找到对应的*.conf文件来编辑server配置。如果server配置是直接写在nginx.conf里的，那就直接在nginx.conf里编辑server配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">443</span>  ssl;</span><br><span class="line">    <span class="attribute">server_name</span>  harrisonxi.com;</span><br><span class="line">    <span class="attribute">ssl_certificate</span>      /etc/letsencrypt/live/harrisonxi.com/fullchain.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>  /etc/letsencrypt/live/harrisonxi.com/privkey.pem;</span><br><span class="line">    <span class="attribute">ssl_protocols</span>        TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span>          HIGH:!aNULL:!MD5;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我的server配置示例就是这样了，记得改成你的证书对应地址。在这样配置的情况下，用HTTP和HTTPS都可以访问到网站。</p><p>用nginx -t验证一下配置文件没有问题，用nginx -s reload重启nginx，生效后就可以测试访问效果了。</p><h1 id="证书续期"><a href="#证书续期" class="headerlink" title="证书续期"></a>证书续期</h1><p>LE提供的证书只有90天有效期，这点也是我觉得比较靠谱的一点，毕竟域名是个可能经常转手的东西。</p><p>Certbot工具也可以自动续期SSL证书，使用renew方法即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./certbot-auto renew</span><br></pre></td></tr></table></figure><p>renew方法的详细介绍参考对应的<a href="https://certbot.eff.org/docs/using.html#renewal" target="_blank" rel="noopener">用户指导</a>。可以新建一个定期计划任务每隔几天自动运行指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./certbot-auto renew --quiet</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网站HTTPS化是迟早的事情了，一是国外各大厂都在推行HTTPS化（例如苹果），一是国内HTTP被劫持篡改的现象越来越严重了。&lt;/p&gt;
&lt;p&gt;现在SSL证书也有免费的了，所以我们可以考虑给自己的站点申请一个免费的证书，让它也支持起HTTPS来。&lt;/p&gt;
&lt;p&gt;国外两大提供免费SSL证书的机构就是&lt;a href=&quot;https://letsencrypt.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Let’s Encrypt&lt;/a&gt;和StartSSL了（别问我为什么不说国内的），然后StartSSL也是因为和国内的某厂产生了关系变得不可信任了，所以今天我能选择的就只有这么一家了。&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://blog.harrisonxi.com/categories/web/"/>
    
    
      <category term="web" scheme="http://blog.harrisonxi.com/tags/web/"/>
    
      <category term="HTTPS" scheme="http://blog.harrisonxi.com/tags/HTTPS/"/>
    
      <category term="SSL" scheme="http://blog.harrisonxi.com/tags/SSL/"/>
    
      <category term="证书" scheme="http://blog.harrisonxi.com/tags/%E8%AF%81%E4%B9%A6/"/>
    
      <category term="nginx" scheme="http://blog.harrisonxi.com/tags/nginx/"/>
    
      <category term="CentOS" scheme="http://blog.harrisonxi.com/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>给nginx创建个自签名SSL证书</title>
    <link href="http://blog.harrisonxi.com/2017/02/%E7%BB%99nginx%E5%88%9B%E5%BB%BA%E4%B8%AA%E8%87%AA%E7%AD%BE%E5%90%8DSSL%E8%AF%81%E4%B9%A6.html"/>
    <id>http://blog.harrisonxi.com/2017/02/给nginx创建个自签名SSL证书.html</id>
    <published>2017-02-21T16:00:00.000Z</published>
    <updated>2018-06-05T03:52:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>自建的内网服务器讲道理HTTP就够用了，奈何iOS设备想要通过网页自动装包就必须要支持HTTPS。</p><p>参考资料：<a href="http://www.akadia.com/services/ssh_test_certificate.html" target="_blank" rel="noopener">How to create a self-signed SSL Certificate</a>，<a href="http://www.cnblogs.com/kyrios/p/tls-and-certificates.html" target="_blank" rel="noopener">TLS/HTTPS 证书生成与验证</a></p><a id="more"></a><h1 id="创建私钥"><a href="#创建私钥" class="headerlink" title="创建私钥"></a>创建私钥</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out server.key 1024</span><br></pre></td></tr></table></figure><p>回车之后就可以得到一个server.key，这就是我们的私钥了。</p><p>因为我们是内部服务器使用，所以不需要进行一些加密操作。想要了解一些细节的可以用help参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa --help</span><br></pre></td></tr></table></figure><h1 id="创建证书签名请求（Certificate-Signing-Request）"><a href="#创建证书签名请求（Certificate-Signing-Request）" class="headerlink" title="创建证书签名请求（Certificate Signing Request）"></a>创建证书签名请求（Certificate Signing Request）</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key server.key -out server.csr</span><br></pre></td></tr></table></figure><p>回车之后会有一堆等着你输入的东西，其它东西我们都不需要关心，唯独一个Common Name要填成对应网站的IP或者域名，剩余的一路直接回车带过：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Country Name (2 letter code) [AU]:</span><br><span class="line">State or Province Name (full name) [Some-State]:</span><br><span class="line">Locality Name (eg, city) []:</span><br><span class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:</span><br><span class="line">Organizational Unit Name (eg, section) []:</span><br><span class="line">Common Name (e.g. server FQDN or YOUR name) []:192.168.1.2</span><br><span class="line">Email Address []:</span><br><span class="line">A challenge password []:</span><br><span class="line">An optional company name []:</span><br></pre></td></tr></table></figure><p>因为iOS设备难以绑host，然后也没有必要买个域名，所以上面我直接填了机器的IP：<strong>192.168.1.2</strong></p><h1 id="创建自签名证书"><a href="#创建自签名证书" class="headerlink" title="创建自签名证书"></a>创建自签名证书</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -in server.csr -signkey server.key -out server.crt</span><br></pre></td></tr></table></figure><p>回车后会得到一个server.crt，就是我们成功创建的自签名证书了。</p><h1 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h1><p>Mac下nginx的配置文件一般是在/usr/local/etc/nginx目录下，打开这个目录下的nginx.conf进行编辑：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>              <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">ssl_certificate</span>     /Users/ios-builder/Documents/server.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /Users/ios-builder/Documents/server.key;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得改成你的证书对应地址，这里就给了个片段进行示意，具体的详细配置方法请自行搜索。</p><p>最后启动或者重启nginx，保证设置生效后测试一下访问效果即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自建的内网服务器讲道理HTTP就够用了，奈何iOS设备想要通过网页自动装包就必须要支持HTTPS。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;a href=&quot;http://www.akadia.com/services/ssh_test_certificate.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;How to create a self-signed SSL Certificate&lt;/a&gt;，&lt;a href=&quot;http://www.cnblogs.com/kyrios/p/tls-and-certificates.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TLS/HTTPS 证书生成与验证&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://blog.harrisonxi.com/categories/web/"/>
    
    
      <category term="web" scheme="http://blog.harrisonxi.com/tags/web/"/>
    
      <category term="HTTPS" scheme="http://blog.harrisonxi.com/tags/HTTPS/"/>
    
      <category term="SSL" scheme="http://blog.harrisonxi.com/tags/SSL/"/>
    
      <category term="证书" scheme="http://blog.harrisonxi.com/tags/%E8%AF%81%E4%B9%A6/"/>
    
      <category term="nginx" scheme="http://blog.harrisonxi.com/tags/nginx/"/>
    
      <category term="Mac" scheme="http://blog.harrisonxi.com/tags/Mac/"/>
    
      <category term="自签名" scheme="http://blog.harrisonxi.com/tags/%E8%87%AA%E7%AD%BE%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>iOS系统window的旋转及自定义window的问题</title>
    <link href="http://blog.harrisonxi.com/2017/02/iOS%E7%B3%BB%E7%BB%9Fwindow%E7%9A%84%E6%97%8B%E8%BD%AC%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89window%E7%9A%84%E9%97%AE%E9%A2%98.html"/>
    <id>http://blog.harrisonxi.com/2017/02/iOS系统window的旋转及自定义window的问题.html</id>
    <published>2017-02-14T16:00:00.000Z</published>
    <updated>2018-06-05T03:52:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>具体某些细节内容和我的开源库<a href="https://github.com/HarrisonXi/TopmostView" target="_blank" rel="noopener">TopmostView</a>相关。</p><p>大家的App都会有全屏的引导页或者Loading界面之类吧？如果你的App结构比较简单，比如RootController是一个NavigationController，而且需要展示全屏页面的时候不存在present新VC或正在做VC切换动画之类的情况，那么直接在RootController的view上面做这些就可以。但是因为这种方案下还有各种意想不到的情况会导致全屏页面展示出问题，所以大家一般又会选择在application window上加一个subview来处理全屏页面的展示。</p><a id="more"></a><p>在App不存在旋转的情况下，这个方法就是最终最优解了。</p><p>在App支持旋转的情况下，要处理的问题就比较多了，下面整理我遇到的一些问题。</p><h1 id="iOS7的window和之后版本iOS系统的表现不一致"><a href="#iOS7的window和之后版本iOS系统的表现不一致" class="headerlink" title="iOS7的window和之后版本iOS系统的表现不一致"></a>iOS7的window和之后版本iOS系统的表现不一致</h1><p>在一个iOS7的iPad上创建一个自定义window，再呼起键盘确保键盘window出现，在横屏的状态下断点并打印一下所有window的列表（过滤了一些我们不需要的信息）：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;__NSArrayM <span class="number">0x165c5d20</span>&gt;(</span><br><span class="line">&lt;<span class="built_in">UIWindow</span>: <span class="number">0x1656e710</span>; frame = (<span class="number">0</span> <span class="number">0</span>; <span class="number">768</span> <span class="number">1024</span>)&gt;,</span><br><span class="line">&lt;<span class="built_in">UITextEffectsWindow</span>: <span class="number">0x165bcdc0</span>; frame = (<span class="number">0</span> <span class="number">0</span>; <span class="number">768</span> <span class="number">1024</span>); transform = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-128</span>, <span class="number">128</span>]&gt;,</span><br><span class="line">&lt;<span class="built_in">UIWindow</span>: <span class="number">0x1659bc70</span>; frame = (<span class="number">0</span> <span class="number">0</span>; <span class="number">768</span> <span class="number">1024</span>); userInteractionEnabled = <span class="literal">NO</span>&gt;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以看到两点：</p><ul><li>window的宽高始终固定是768x1024，即竖屏的状态</li><li>键盘window自带了一个transform属性，正好可以将竖屏的window旋转成横屏的大小&amp;位置</li></ul><p>键盘window是iOS7里，系统唯一自动处理了的window，因此维持其subview在横屏的时候frame = (0 0; 1024 768)，竖屏的时候frame = (0 0; 768 1024)就可以保证展示正常。</p><p>而其它window的frame和transform都没有被处理，系统是怎么保证我们的界面显示正常呢？打印application window的subview看一下就明白了（过滤了一些我们不需要的信息）：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;__NSArrayM <span class="number">0x165c09f0</span>&gt;(</span><br><span class="line">&lt;<span class="built_in">UILayoutContainerView</span>: <span class="number">0x16570400</span>; frame = (<span class="number">0</span> <span class="number">0</span>; <span class="number">768</span> <span class="number">1024</span>); transform = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]; autoresize = W+H;&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>原来系统是处理了window的subview，给它加上了一个transform。所以在iOS7下面给键盘window外其它window加subview的时候，需要在设备旋转的时候处理一下subview的transform属性，保持和系统管理的那个subview一致。</p><h1 id="iOS8-10的window"><a href="#iOS8-10的window" class="headerlink" title="iOS8-10的window"></a>iOS8-10的window</h1><p>先拿个iOS8的iPhone做类似的实验（过滤了一些我们不需要的信息）：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;__NSArrayM <span class="number">0x78977ab0</span>&gt;(</span><br><span class="line">&lt;<span class="built_in">UIWindow</span>: <span class="number">0x7889e8e0</span>; frame = (<span class="number">0</span> <span class="number">0</span>; <span class="number">568</span> <span class="number">320</span>)&gt;,</span><br><span class="line">&lt;<span class="built_in">UITextEffectsWindow</span>: <span class="number">0x788ae8c0</span>; frame = (<span class="number">0</span> <span class="number">0</span>; <span class="number">568</span> <span class="number">320</span>); autoresize = W+H&gt;,</span><br><span class="line">&lt;<span class="built_in">UIWindow</span>: <span class="number">0x788d9fa0</span>; frame = (<span class="number">0</span> <span class="number">0</span>; <span class="number">568</span> <span class="number">320</span>); userInteractionEnabled = <span class="literal">NO</span>&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以看到横屏的时候，系统为window维护了正确的宽高，即使我并没有给自定义window增加autoresize = W+H的属性。</p><p>顺带看一下application window的subview是什么样子的（过滤了一些我们不需要的信息）：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;__NSArrayM <span class="number">0x788aeb90</span>&gt;(</span><br><span class="line">&lt;<span class="built_in">UILayoutContainerView</span>: <span class="number">0x7863bdc0</span>; frame = (<span class="number">0</span> <span class="number">0</span>; <span class="number">568</span> <span class="number">320</span>); autoresize = W+H&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>系统管理的view加了autoresize = W+H属性，应该就是利用这个保证了横竖屏旋转时subview的尺寸正确。</p><p>在iOS9/10的表现基本一致，总体来说我们要做的就是在设备旋转时保证我们自己添加的subview尺寸正确。</p><h1 id="设备旋转事件的系统通知"><a href="#设备旋转事件的系统通知" class="headerlink" title="设备旋转事件的系统通知"></a>设备旋转事件的系统通知</h1><p>在iOS中，设备方向相关的定义都是叫做StatusBarOrientation，下面列出一些常用的定义：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得当前的设备方向</span></span><br><span class="line">[<span class="built_in">UIApplication</span> sharedApplication].statusBarOrientation</span><br><span class="line"><span class="comment">// 设备即将改变方向的通知事件name</span></span><br><span class="line"><span class="built_in">UIApplicationWillChangeStatusBarOrientationNotification</span></span><br><span class="line"><span class="comment">// 设备已经改变方向的通知事件name</span></span><br><span class="line"><span class="built_in">UIApplicationDidChangeStatusBarOrientationNotification</span></span><br><span class="line"><span class="comment">// 通知事件数据字典里自定义数据的key</span></span><br><span class="line"><span class="built_in">UIApplicationStatusBarOrientationUserInfoKey</span></span><br><span class="line"><span class="comment">// 旋转动画时长</span></span><br><span class="line">[<span class="built_in">UIApplication</span> sharedApplication].statusBarOrientationAnimationDuration</span><br></pre></td></tr></table></figure><p>因为iOS7和之后系统表现不一致，所以我们最好是自己监视通知，自己维护加到window的subview的状态。</p><p>因为我们期望跟着系统旋转动画的时候一起处理好我们的subview，所以应该监视WillChange通知。</p><p>WillChange通知发生的时候，statusBarOrientation会取得旋转前的方向，通知内的数据会是要旋转到的方向。</p><p>DidChange通知发生的时候，statusBarOrientation会取得旋转后的方向，通知内的数据会是旋转前的方向。</p><p>取得了将要旋转到的方向，对我们的subview做一个和系统旋转动画时长相同的动画就可以。需要注意的是，这个statusBarOrientationAnimationDuration是旋转90度用的时长，旋转180度时要x2（不过其实可以不太在意）。</p><h1 id="关于WindowLevel"><a href="#关于WindowLevel" class="headerlink" title="关于WindowLevel"></a>关于WindowLevel</h1><p>系统定义了三种WindowLevel，值其实都是CGFloat型的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通window的level，实际值是0</span></span><br><span class="line"><span class="built_in">UIWindowLevel</span> <span class="built_in">UIWindowLevelNormal</span>;</span><br><span class="line"><span class="comment">// Alert弹窗window的level，实际值是2000</span></span><br><span class="line"><span class="built_in">UIWindowLevel</span> <span class="built_in">UIWindowLevelAlert</span>;</span><br><span class="line"><span class="comment">// 状态栏window的level，实际值是1000</span></span><br><span class="line"><span class="built_in">UIWindowLevel</span> <span class="built_in">UIWindowLevelStatusBa</span>;</span><br></pre></td></tr></table></figure><p>这三个我注释的默认值没变过，但是不知道以后会不会变，使用的时候还是应该要使用对应的常量定义。</p><p>值得一提的是UIWindowLevelAlert，系统创建的alert window实际的level会有一定的偏差（<a href="https://stackoverflow.com/questions/15422898/how-to-show-a-uiwindow-over-the-keyboard-but-under-a-uialertview" target="_blank" rel="noopener">参照资料</a>，我也遇到过），需要比alert window层级高或者低的时候建议+50或者-50（因为键盘window的level是2100，折中）。</p><h1 id="自定义window的其他注意点"><a href="#自定义window的其他注意点" class="headerlink" title="自定义window的其他注意点"></a>自定义window的其他注意点</h1><p>userInteractionEnabled需要记得设置成NO，不然上层的window会截获各种触摸事件，App就点不动了。</p><p>如果有多处代码需要同时管理userInteractionEnabled属性，最好写一个计数的manager来统一管理。</p><p>另外很诡异的一点是，一定要给window设置一个空的rootViewController：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.rootViewController = [<span class="built_in">UIViewController</span> new];</span><br></pre></td></tr></table></figure><p>如果不设置这个rootViewController，系统在某些设备上无法正确的维护window的尺寸和旋转状态。</p><p>自定义window是不需要makeKeyAndVisible的，只需要将hidden设为NO就会显示，设为YES就会消失。</p><h1 id="诞生的开源库"><a href="#诞生的开源库" class="headerlink" title="诞生的开源库"></a>诞生的开源库</h1><p>实验完所有这些东西，诞生了开源库：<a href="https://github.com/HarrisonXi/TopmostView" target="_blank" rel="noopener">TopmostView</a></p><p>如果你不想自己再处理一遍这些问题，可以直接使用这个库。</p><p>有些最新的尝试我会放在<a href="https://github.com/HarrisonXi/TopmostView/tree/develop" target="_blank" rel="noopener">develop</a>分支，遇到问题也欢迎带着<a href="https://github.com/HarrisonXi/TopmostView/issues" target="_blank" rel="noopener">issue</a>来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;具体某些细节内容和我的开源库&lt;a href=&quot;https://github.com/HarrisonXi/TopmostView&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TopmostView&lt;/a&gt;相关。&lt;/p&gt;
&lt;p&gt;大家的App都会有全屏的引导页或者Loading界面之类吧？如果你的App结构比较简单，比如RootController是一个NavigationController，而且需要展示全屏页面的时候不存在present新VC或正在做VC切换动画之类的情况，那么直接在RootController的view上面做这些就可以。但是因为这种方案下还有各种意想不到的情况会导致全屏页面展示出问题，所以大家一般又会选择在application window上加一个subview来处理全屏页面的展示。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://blog.harrisonxi.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://blog.harrisonxi.com/tags/iOS/"/>
    
      <category term="开源" scheme="http://blog.harrisonxi.com/tags/%E5%BC%80%E6%BA%90/"/>
    
      <category term="window" scheme="http://blog.harrisonxi.com/tags/window/"/>
    
      <category term="旋转" scheme="http://blog.harrisonxi.com/tags/%E6%97%8B%E8%BD%AC/"/>
    
      <category term="自定义" scheme="http://blog.harrisonxi.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89/"/>
    
  </entry>
  
</feed>
